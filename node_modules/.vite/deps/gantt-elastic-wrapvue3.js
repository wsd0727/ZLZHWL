import "./chunk-TZ2LBFID.js";
import {
  vShow,
  withKeys,
  withModifiers
} from "./chunk-QN6PLAOZ.js";
import {
  Fragment,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createTextVNode,
  createVNode,
  mergeProps,
  normalizeClass,
  normalizeStyle,
  onMounted,
  onUnmounted,
  openBlock,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDynamicComponent,
  toDisplayString,
  watch,
  withCtx,
  withDirectives
} from "./chunk-UI7STE7Z.js";
import {
  ref,
  toRefs
} from "./chunk-YKZOVGSZ.js";
import "./chunk-GFT2G5UO.js";

// node_modules/gantt-elastic-wrapvue3/dist/GanttElastic.es.js
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a, prop, b2[prop]);
    }
  return a;
};
var __spreadProps = (a, b2) => __defProps(a, __getOwnPropDescs(b2));
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var dayjs_min = { exports: {} };
(function(module, exports) {
  !function(t, e) {
    module.exports = e();
  }(commonjsGlobal, function() {
    var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s2 = "minute", u2 = "hour", a = "day", o2 = "week", f2 = "month", h2 = "quarter", c2 = "year", d2 = "date", $ = "Invalid Date", l = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_") }, m2 = function(t2, e2, n2) {
      var r2 = String(t2);
      return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
    }, g2 = { s: m2, z: function(t2) {
      var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
      return (e2 <= 0 ? "+" : "-") + m2(r2, 2, "0") + ":" + m2(i2, 2, "0");
    }, m: function t2(e2, n2) {
      if (e2.date() < n2.date())
        return -t2(n2, e2);
      var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, f2), s3 = n2 - i2 < 0, u3 = e2.clone().add(r2 + (s3 ? -1 : 1), f2);
      return +(-(r2 + (n2 - i2) / (s3 ? i2 - u3 : u3 - i2)) || 0);
    }, a: function(t2) {
      return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
    }, p: function(t2) {
      return { M: f2, y: c2, w: o2, d: a, D: d2, h: u2, m: s2, s: i, ms: r, Q: h2 }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t2) {
      return t2 === void 0;
    } }, v2 = "en", D = {};
    D[v2] = M;
    var p2 = function(t2) {
      return t2 instanceof _;
    }, S2 = function t2(e2, n2, r2) {
      var i2;
      if (!e2)
        return v2;
      if (typeof e2 == "string") {
        var s3 = e2.toLowerCase();
        D[s3] && (i2 = s3), n2 && (D[s3] = n2, i2 = s3);
        var u3 = e2.split("-");
        if (!i2 && u3.length > 1)
          return t2(u3[0]);
      } else {
        var a2 = e2.name;
        D[a2] = e2, i2 = a2;
      }
      return !r2 && i2 && (v2 = i2), i2 || !r2 && v2;
    }, w2 = function(t2, e2) {
      if (p2(t2))
        return t2.clone();
      var n2 = typeof e2 == "object" ? e2 : {};
      return n2.date = t2, n2.args = arguments, new _(n2);
    }, O = g2;
    O.l = S2, O.i = p2, O.w = function(t2, e2) {
      return w2(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
    };
    var _ = function() {
      function M2(t2) {
        this.$L = S2(t2.locale, null, true), this.parse(t2);
      }
      var m3 = M2.prototype;
      return m3.parse = function(t2) {
        this.$d = function(t3) {
          var e2 = t3.date, n2 = t3.utc;
          if (e2 === null)
            return /* @__PURE__ */ new Date(NaN);
          if (O.u(e2))
            return /* @__PURE__ */ new Date();
          if (e2 instanceof Date)
            return new Date(e2);
          if (typeof e2 == "string" && !/Z$/i.test(e2)) {
            var r2 = e2.match(l);
            if (r2) {
              var i2 = r2[2] - 1 || 0, s3 = (r2[7] || "0").substring(0, 3);
              return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s3)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s3);
            }
          }
          return new Date(e2);
        }(t2), this.$x = t2.x || {}, this.init();
      }, m3.init = function() {
        var t2 = this.$d;
        this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
      }, m3.$utils = function() {
        return O;
      }, m3.isValid = function() {
        return !(this.$d.toString() === $);
      }, m3.isSame = function(t2, e2) {
        var n2 = w2(t2);
        return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
      }, m3.isAfter = function(t2, e2) {
        return w2(t2) < this.startOf(e2);
      }, m3.isBefore = function(t2, e2) {
        return this.endOf(e2) < w2(t2);
      }, m3.$g = function(t2, e2, n2) {
        return O.u(t2) ? this[e2] : this.set(n2, t2);
      }, m3.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m3.valueOf = function() {
        return this.$d.getTime();
      }, m3.startOf = function(t2, e2) {
        var n2 = this, r2 = !!O.u(e2) || e2, h3 = O.p(t2), $2 = function(t3, e3) {
          var i2 = O.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
          return r2 ? i2 : i2.endOf(a);
        }, l2 = function(t3, e3) {
          return O.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
        }, y3 = this.$W, M3 = this.$M, m4 = this.$D, g3 = "set" + (this.$u ? "UTC" : "");
        switch (h3) {
          case c2:
            return r2 ? $2(1, 0) : $2(31, 11);
          case f2:
            return r2 ? $2(1, M3) : $2(0, M3 + 1);
          case o2:
            var v3 = this.$locale().weekStart || 0, D2 = (y3 < v3 ? y3 + 7 : y3) - v3;
            return $2(r2 ? m4 - D2 : m4 + (6 - D2), M3);
          case a:
          case d2:
            return l2(g3 + "Hours", 0);
          case u2:
            return l2(g3 + "Minutes", 1);
          case s2:
            return l2(g3 + "Seconds", 2);
          case i:
            return l2(g3 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m3.endOf = function(t2) {
        return this.startOf(t2, false);
      }, m3.$set = function(t2, e2) {
        var n2, o3 = O.p(t2), h3 = "set" + (this.$u ? "UTC" : ""), $2 = (n2 = {}, n2[a] = h3 + "Date", n2[d2] = h3 + "Date", n2[f2] = h3 + "Month", n2[c2] = h3 + "FullYear", n2[u2] = h3 + "Hours", n2[s2] = h3 + "Minutes", n2[i] = h3 + "Seconds", n2[r] = h3 + "Milliseconds", n2)[o3], l2 = o3 === a ? this.$D + (e2 - this.$W) : e2;
        if (o3 === f2 || o3 === c2) {
          var y3 = this.clone().set(d2, 1);
          y3.$d[$2](l2), y3.init(), this.$d = y3.set(d2, Math.min(this.$D, y3.daysInMonth())).$d;
        } else
          $2 && this.$d[$2](l2);
        return this.init(), this;
      }, m3.set = function(t2, e2) {
        return this.clone().$set(t2, e2);
      }, m3.get = function(t2) {
        return this[O.p(t2)]();
      }, m3.add = function(r2, h3) {
        var d3, $2 = this;
        r2 = Number(r2);
        var l2 = O.p(h3), y3 = function(t2) {
          var e2 = w2($2);
          return O.w(e2.date(e2.date() + Math.round(t2 * r2)), $2);
        };
        if (l2 === f2)
          return this.set(f2, this.$M + r2);
        if (l2 === c2)
          return this.set(c2, this.$y + r2);
        if (l2 === a)
          return y3(1);
        if (l2 === o2)
          return y3(7);
        var M3 = (d3 = {}, d3[s2] = e, d3[u2] = n, d3[i] = t, d3)[l2] || 1, m4 = this.$d.getTime() + r2 * M3;
        return O.w(m4, this);
      }, m3.subtract = function(t2, e2) {
        return this.add(-1 * t2, e2);
      }, m3.format = function(t2) {
        var e2 = this, n2 = this.$locale();
        if (!this.isValid())
          return n2.invalidDate || $;
        var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = O.z(this), s3 = this.$H, u3 = this.$m, a2 = this.$M, o3 = n2.weekdays, f3 = n2.months, h3 = function(t3, n3, i3, s4) {
          return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s4);
        }, c3 = function(t3) {
          return O.s(s3 % 12 || 12, t3, "0");
        }, d3 = n2.meridiem || function(t3, e3, n3) {
          var r3 = t3 < 12 ? "AM" : "PM";
          return n3 ? r3.toLowerCase() : r3;
        }, l2 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a2 + 1, MM: O.s(a2 + 1, 2, "0"), MMM: h3(n2.monthsShort, a2, f3, 3), MMMM: h3(f3, a2), D: this.$D, DD: O.s(this.$D, 2, "0"), d: String(this.$W), dd: h3(n2.weekdaysMin, this.$W, o3, 2), ddd: h3(n2.weekdaysShort, this.$W, o3, 3), dddd: o3[this.$W], H: String(s3), HH: O.s(s3, 2, "0"), h: c3(1), hh: c3(2), a: d3(s3, u3, true), A: d3(s3, u3, false), m: String(u3), mm: O.s(u3, 2, "0"), s: String(this.$s), ss: O.s(this.$s, 2, "0"), SSS: O.s(this.$ms, 3, "0"), Z: i2 };
        return r2.replace(y2, function(t3, e3) {
          return e3 || l2[t3] || i2.replace(":", "");
        });
      }, m3.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m3.diff = function(r2, d3, $2) {
        var l2, y3 = O.p(d3), M3 = w2(r2), m4 = (M3.utcOffset() - this.utcOffset()) * e, g3 = this - M3, v3 = O.m(this, M3);
        return v3 = (l2 = {}, l2[c2] = v3 / 12, l2[f2] = v3, l2[h2] = v3 / 3, l2[o2] = (g3 - m4) / 6048e5, l2[a] = (g3 - m4) / 864e5, l2[u2] = g3 / n, l2[s2] = g3 / e, l2[i] = g3 / t, l2)[y3] || g3, $2 ? v3 : O.a(v3);
      }, m3.daysInMonth = function() {
        return this.endOf(f2).$D;
      }, m3.$locale = function() {
        return D[this.$L];
      }, m3.locale = function(t2, e2) {
        if (!t2)
          return this.$L;
        var n2 = this.clone(), r2 = S2(t2, e2, true);
        return r2 && (n2.$L = r2), n2;
      }, m3.clone = function() {
        return O.w(this.$d, this);
      }, m3.toDate = function() {
        return new Date(this.valueOf());
      }, m3.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m3.toISOString = function() {
        return this.$d.toISOString();
      }, m3.toString = function() {
        return this.$d.toUTCString();
      }, M2;
    }(), T = _.prototype;
    return w2.prototype = T, [["$ms", r], ["$s", i], ["$m", s2], ["$H", u2], ["$W", a], ["$M", f2], ["$y", c2], ["$D", d2]].forEach(function(t2) {
      T[t2[1]] = function(e2) {
        return this.$g(e2, t2[0], t2[1]);
      };
    }), w2.extend = function(t2, e2) {
      return t2.$i || (t2(e2, _, w2), t2.$i = true), w2;
    }, w2.locale = S2, w2.isDayjs = p2, w2.unix = function(t2) {
      return w2(1e3 * t2);
    }, w2.en = D[v2], w2.Ls = D, w2.p = {}, w2;
  });
})(dayjs_min);
var dayjs = dayjs_min.exports;
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
var _sfc_main$i = {
  name: "Expander",
  inject: ["root"],
  props: ["tasks", "options", "type"],
  data() {
    const border = 0.5;
    return {
      border,
      borderStyle: {
        "stroke-width": border
      },
      lineOffset: 5
    };
  },
  computed: {
    style() {
      if (this.type !== "taskList") {
        return {};
      }
      const margin = this.root.state.options.taskList.expander.margin;
      const padding = this.tasks[0].parents.length * this.root.state.options.taskList.expander.padding;
      return {
        "padding-left": padding + margin + "px",
        margin: "auto 0"
      };
    },
    allChildren() {
      const children = [];
      this.tasks.forEach((task) => {
        task.allChildren.forEach((childId) => {
          children.push(childId);
        });
      });
      return children;
    },
    collapsed() {
      if (this.tasks.length === 0) {
        return false;
      }
      let collapsed = 0;
      for (let i = 0, len = this.tasks.length; i < len; i++) {
        if (this.tasks[i].collapsed) {
          collapsed++;
        }
      }
      return collapsed === this.tasks.length;
    }
  },
  methods: {
    getClassPrefix(full = true) {
      return `${full ? "gantt-elastic__" : ""}${this.options.type}-expander`;
    },
    toggle() {
      if (this.tasks.length === 0) {
        return;
      }
      const collapsed = !this.collapsed;
      this.tasks.forEach((task) => {
        task.collapsed = collapsed;
      });
    }
  }
};
var _hoisted_1$d = ["width", "height"];
var _hoisted_2$a = ["x", "y", "width", "height"];
var _hoisted_3$8 = ["x1", "y1", "x2", "y2"];
var _hoisted_4$6 = ["x1", "y1", "x2", "y2"];
function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass($options.getClassPrefix() + "-wrapper"),
    style: normalizeStyle(__spreadValues(__spreadValues({}, $options.root.style[$options.getClassPrefix(false) + "-wrapper"]), $options.style))
  }, [
    $options.allChildren.length ? (openBlock(), createElementBlock("svg", {
      key: 0,
      class: normalizeClass($options.getClassPrefix() + "-content"),
      style: normalizeStyle(__spreadValues({}, $options.root.style[$options.getClassPrefix(false) + "-content"])),
      width: $props.options.size,
      height: $props.options.size,
      onClick: _cache[0] || (_cache[0] = (...args) => $options.toggle && $options.toggle(...args))
    }, [
      createBaseVNode("rect", {
        class: normalizeClass($options.getClassPrefix() + "-border"),
        style: normalizeStyle(__spreadValues(__spreadValues({}, $options.root.style[$options.getClassPrefix(false) + "-border"]), $data.borderStyle)),
        x: $data.border,
        y: $data.border,
        width: $props.options.size - $data.border * 2,
        height: $props.options.size - $data.border * 2,
        rx: "2",
        ry: "2"
      }, null, 14, _hoisted_2$a),
      $options.allChildren.length ? (openBlock(), createElementBlock("line", {
        key: 0,
        class: normalizeClass($options.getClassPrefix() + "-line"),
        style: normalizeStyle(__spreadValues({}, $options.root.style[$options.getClassPrefix(false) + "-line"])),
        x1: $data.lineOffset,
        y1: $props.options.size / 2,
        x2: $props.options.size - $data.lineOffset,
        y2: $props.options.size / 2
      }, null, 14, _hoisted_3$8)) : createCommentVNode("", true),
      $options.collapsed ? (openBlock(), createElementBlock("line", {
        key: 1,
        class: normalizeClass($options.getClassPrefix() + "-line"),
        style: normalizeStyle(__spreadValues({}, $options.root.style[$options.getClassPrefix(false) + "-line"])),
        x1: $props.options.size / 2,
        y1: $data.lineOffset,
        x2: $props.options.size / 2,
        y2: $props.options.size - $data.lineOffset
      }, null, 14, _hoisted_4$6)) : createCommentVNode("", true)
    ], 14, _hoisted_1$d)) : createCommentVNode("", true)
  ], 6);
}
var Expander = _export_sfc(_sfc_main$i, [["render", _sfc_render$i]]);
var _sfc_main$h = {
  name: "TaskListHeader",
  components: {
    TaskListExpander: Expander
  },
  inject: ["root"],
  data() {
    return {
      resizer: {
        moving: false,
        x: 0
      }
    };
  },
  computed: {
    collapsible() {
      return this.root.state.tasks.filter((task) => task.allChildren.length > 0);
    }
  },
  methods: {
    getStyle(column) {
      return {
        width: column.finalWidth + "px"
      };
    },
    resizerMouseDown(event, column) {
      if (!this.resizer.moving) {
        this.resizer.moving = column;
        this.resizer.x = event.clientX;
        this.resizer.initialWidth = column.width;
        this.$root.emitter.emit("taskList-column-width-change-start", this.resizer.moving);
      }
    },
    resizerMouseMove(event) {
      if (this.resizer.moving) {
        const lastWidth = this.resizer.moving.width;
        this.resizer.moving.width = this.resizer.initialWidth + event.clientX - this.resizer.x;
        if (this.resizer.moving.width < this.root.state.options.taskList.minWidth) {
          this.resizer.moving.width = this.root.state.options.taskList.minWidth;
        }
        if (lastWidth !== this.resizer.moving.width) {
          this.$root.emitter.emit("taskList-column-width-change", this.resizer.moving);
        }
      }
    },
    resizerMouseUp(event) {
      if (this.resizer.moving) {
        this.$root.emitter.emit("taskList-column-width-change-stop", this.resizer.moving);
        this.resizer.moving = false;
      }
    }
  },
  created() {
    this.mouseUpListener = document.addEventListener("mouseup", this.resizerMouseUp.bind(this));
    this.mouseMoveListener = document.addEventListener("mousemove", this.resizerMouseMove.bind(this));
    this.$root.emitter.on("main-view-mousemove", this.resizerMouseMove);
    this.$root.emitter.on("main-view-mouseup", this.resizerMouseUp);
  },
  beforeDestroy() {
    document.removeEventListener("mouseup", this.resizerMouseUp);
    document.removeEventListener("mousemove", this.resizerMouseMove);
  }
};
var _hoisted_1$c = ["column"];
var _hoisted_2$9 = ["column", "onMousedown"];
function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_task_list_expander = resolveComponent("task-list-expander");
  return openBlock(), createElementBlock("div", {
    class: "gantt-elastic__task-list-header",
    style: normalizeStyle(__spreadProps(__spreadValues({}, $options.root.style["task-list-header"]), {
      height: `${$options.root.state.options.calendar.height}px`,
      "margin-bottom": `${$options.root.state.options.calendar.gap}px`
    }))
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList($options.root.getTaskListColumns, (column) => {
      return openBlock(), createElementBlock("div", {
        class: "gantt-elastic__task-list-header-column",
        style: normalizeStyle(__spreadValues(__spreadValues(__spreadValues({}, $options.root.style["task-list-header-column"]), column.style["task-list-header-column"]), $options.getStyle(column))),
        key: column._id
      }, [
        column.expander ? (openBlock(), createBlock(_component_task_list_expander, {
          key: 0,
          tasks: $options.collapsible,
          options: $options.root.state.options.taskList.expander
        }, null, 8, ["tasks", "options"])) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: "gantt-elastic__task-list-header-label",
          style: normalizeStyle(__spreadValues(__spreadValues({}, $options.root.style["task-list-header-label"]), column.style["task-list-header-label"])),
          column,
          onMouseup: _cache[0] || (_cache[0] = (...args) => $options.resizerMouseUp && $options.resizerMouseUp(...args))
        }, toDisplayString(column.label), 45, _hoisted_1$c),
        createBaseVNode("div", {
          class: "gantt-elastic__task-list-header-resizer-wrapper",
          style: normalizeStyle(__spreadValues(__spreadValues({}, $options.root.style["task-list-header-resizer-wrapper"]), column.style["task-list-header-resizer-wrapper"])),
          column,
          onMousedown: ($event) => $options.resizerMouseDown($event, column)
        }, [
          createBaseVNode("div", {
            class: "gantt-elastic__task-list-header-resizer",
            style: normalizeStyle(__spreadValues(__spreadValues({}, $options.root.style["task-list-header-resizer"]), column.style["task-list-header-resizer"]))
          }, [
            createBaseVNode("div", {
              class: "gantt-elastic__task-list-header-resizer-dot",
              style: normalizeStyle(__spreadValues(__spreadValues({}, $options.root.style["task-list-header-resizer-dot"]), column.style["task-list-header-resizer-dot"]))
            }, null, 4),
            createBaseVNode("div", {
              class: "gantt-elastic__task-list-header-resizer-dot",
              style: normalizeStyle(__spreadValues(__spreadValues({}, $options.root.style["task-list-header-resizer-dot"]), column.style["task-list-header-resizer-dot"]))
            }, null, 4),
            createBaseVNode("div", {
              class: "gantt-elastic__task-list-header-resizer-dot",
              style: normalizeStyle(__spreadValues(__spreadValues({}, $options.root.style["task-list-header-resizer-dot"]), column.style["task-list-header-resizer-dot"]))
            }, null, 4)
          ], 4)
        ], 44, _hoisted_2$9)
      ], 4);
    }), 128))
  ], 4);
}
var TaskListHeader = _export_sfc(_sfc_main$h, [["render", _sfc_render$h]]);
var _sfc_main$g = {
  name: "ItemColumn",
  inject: ["root"],
  props: ["column", "task"],
  data() {
    return {};
  },
  methods: {
    emitEvent(eventName, event) {
      if (typeof this.column.events !== "undefined" && typeof this.column.events[eventName] === "function") {
        this.column.events[eventName]({ event, data: this.task, column: this.column });
      }
      this.root.$emit(`taskList-${this.task.type}-${eventName}`, { event, data: this.task, column: this.column });
    }
  },
  computed: {
    html() {
      if (typeof this.column.html !== "undefined" && this.column.html === true) {
        return true;
      }
      return false;
    },
    value() {
      if (typeof this.column.value === "function") {
        return this.column.value(this.task);
      }
      return this.task[this.column.value];
    },
    itemColumnStyle() {
      return __spreadProps(__spreadValues(__spreadValues({}, this.root.style["task-list-item-column"]), this.column.style["task-list-item-column"]), {
        width: this.column.finalWidth + "px",
        height: this.column.height + "px"
      });
    },
    wrapperStyle() {
      return __spreadValues(__spreadValues({}, this.root.style["task-list-item-value-wrapper"]), this.column.style["task-list-item-value-wrapper"]);
    },
    containerStyle() {
      return __spreadValues(__spreadValues({}, this.root.style["task-list-item-value-container"]), this.column.style["task-list-item-value-container"]);
    },
    valueStyle() {
      return __spreadValues(__spreadValues({}, this.root.style["task-list-item-value"]), this.column.style["task-list-item-value"]);
    }
  }
};
var _hoisted_1$b = ["innerHTML"];
function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "gantt-elastic__task-list-item-column",
    style: normalizeStyle($options.itemColumnStyle)
  }, [
    createBaseVNode("div", {
      class: "gantt-elastic__task-list-item-value-wrapper",
      style: normalizeStyle($options.wrapperStyle)
    }, [
      renderSlot(_ctx.$slots, "default"),
      createBaseVNode("div", {
        class: "gantt-elastic__task-list-item-value-container",
        style: normalizeStyle($options.containerStyle)
      }, [
        !$options.html ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "gantt-elastic__task-list-item-value",
          style: normalizeStyle($options.valueStyle),
          onClick: _cache[0] || (_cache[0] = ($event) => $options.emitEvent("click", $event)),
          onMouseenter: _cache[1] || (_cache[1] = ($event) => $options.emitEvent("mouseenter", $event)),
          onMouseover: _cache[2] || (_cache[2] = ($event) => $options.emitEvent("mouseover", $event)),
          onMouseout: _cache[3] || (_cache[3] = ($event) => $options.emitEvent("mouseout", $event)),
          onMousemove: _cache[4] || (_cache[4] = ($event) => $options.emitEvent("mousemove", $event)),
          onMousedown: _cache[5] || (_cache[5] = ($event) => $options.emitEvent("mousedown", $event)),
          onMouseup: _cache[6] || (_cache[6] = ($event) => $options.emitEvent("mouseup", $event)),
          onMousewheel: _cache[7] || (_cache[7] = ($event) => $options.emitEvent("mousewheel", $event)),
          onTouchstart: _cache[8] || (_cache[8] = ($event) => $options.emitEvent("touchstart", $event)),
          onTouchmove: _cache[9] || (_cache[9] = ($event) => $options.emitEvent("touchmove", $event)),
          onTouchend: _cache[10] || (_cache[10] = ($event) => $options.emitEvent("touchend", $event))
        }, toDisplayString($options.value), 37)) : (openBlock(), createElementBlock("div", {
          key: 1,
          class: "gantt-elastic__task-list-item-value",
          style: normalizeStyle($options.valueStyle),
          onClick: _cache[11] || (_cache[11] = ($event) => $options.emitEvent("click", $event)),
          onMouseenter: _cache[12] || (_cache[12] = ($event) => $options.emitEvent("mouseenter", $event)),
          onMouseover: _cache[13] || (_cache[13] = ($event) => $options.emitEvent("mouseover", $event)),
          onMouseout: _cache[14] || (_cache[14] = ($event) => $options.emitEvent("mouseout", $event)),
          onMousemove: _cache[15] || (_cache[15] = ($event) => $options.emitEvent("mousemove", $event)),
          onMousedown: _cache[16] || (_cache[16] = ($event) => $options.emitEvent("mousedown", $event)),
          onMouseup: _cache[17] || (_cache[17] = ($event) => $options.emitEvent("mouseup", $event)),
          onMousewheel: _cache[18] || (_cache[18] = ($event) => $options.emitEvent("mousewheel", $event)),
          onTouchstart: _cache[19] || (_cache[19] = ($event) => $options.emitEvent("touchstart", $event)),
          onTouchmove: _cache[20] || (_cache[20] = ($event) => $options.emitEvent("touchmove", $event)),
          onTouchend: _cache[21] || (_cache[21] = ($event) => $options.emitEvent("touchend", $event)),
          innerHTML: $options.value
        }, null, 44, _hoisted_1$b))
      ], 4)
    ], 4)
  ], 4);
}
var ItemColumn = _export_sfc(_sfc_main$g, [["render", _sfc_render$g]]);
var _sfc_main$f = {
  name: "TaskListItem",
  components: {
    TaskListExpander: Expander,
    ItemColumn
  },
  inject: ["root"],
  props: ["task"],
  data() {
    return {};
  },
  computed: {
    columns() {
      return this.root.state.options.taskList.columns;
    }
  }
};
function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_task_list_expander = resolveComponent("task-list-expander");
  const _component_item_column = resolveComponent("item-column");
  return openBlock(), createElementBlock("div", {
    class: "gantt-elastic__task-list-item",
    style: normalizeStyle(__spreadValues({}, $options.root.style["task-list-item"]))
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList($options.columns, (column) => {
      return openBlock(), createBlock(_component_item_column, {
        key: column._id,
        column,
        task: $props.task
      }, {
        default: withCtx(() => [
          column.expander ? (openBlock(), createBlock(_component_task_list_expander, {
            key: 0,
            tasks: [$props.task],
            options: $options.root.state.options.taskList.expander,
            type: "taskList"
          }, null, 8, ["tasks", "options"])) : createCommentVNode("", true)
        ]),
        _: 2
      }, 1032, ["column", "task"]);
    }), 128))
  ], 4);
}
var TaskListItem = _export_sfc(_sfc_main$f, [["render", _sfc_render$f]]);
var _sfc_main$e = {
  name: "TaskList",
  components: {
    TaskListHeader,
    TaskListItem
  },
  inject: ["root"],
  data() {
    return {};
  },
  mounted() {
    this.root.state.refs.taskListWrapper = this.$refs.taskListWrapper;
    this.root.state.refs.taskList = this.$refs.taskList;
    this.root.state.refs.taskListItems = this.$refs.taskListItems;
  }
};
function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_task_list_header = resolveComponent("task-list-header");
  const _component_task_list_item = resolveComponent("task-list-item");
  return withDirectives((openBlock(), createElementBlock("div", {
    class: "gantt-elastic__task-list-wrapper",
    ref: "taskListWrapper",
    style: normalizeStyle(__spreadProps(__spreadValues({}, $options.root.style["task-list-wrapper"]), { width: "100%", height: "100%" }))
  }, [
    createBaseVNode("div", {
      class: "gantt-elastic__task-list",
      style: normalizeStyle(__spreadValues({}, $options.root.style["task-list"])),
      ref: "taskList"
    }, [
      createVNode(_component_task_list_header),
      createBaseVNode("div", {
        class: "gantt-elastic__task-list-items",
        ref: "taskListItems",
        style: normalizeStyle(__spreadProps(__spreadValues({}, $options.root.style["task-list-items"]), { height: $options.root.state.options.rowsHeight + "px" }))
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($options.root.visibleTasks, (task) => {
          return openBlock(), createBlock(_component_task_list_item, {
            key: task.id,
            task
          }, null, 8, ["task"]);
        }), 128))
      ], 4)
    ], 4)
  ], 4)), [
    [vShow, $options.root.state.options.taskList.display]
  ]);
}
var TaskList = _export_sfc(_sfc_main$e, [["render", _sfc_render$e]]);
var _sfc_main$d = {
  name: "Grid",
  inject: ["root"],
  data() {
    return {};
  },
  created() {
    this.$root.emitter.on("recenterPosition", this.recenterPosition);
  },
  mounted() {
    this.$nextTick(() => {
      this.$nextTick(() => {
        this.root.scrollToTime(this.timeLinePosition.time);
      });
    });
  },
  methods: {
    recenterPosition() {
      this.root.scrollToTime(this.timeLinePosition.time);
    }
  },
  computed: {
    verticalLines() {
      let lines = [];
      const state = this.root.state;
      state.options.times.steps.forEach((step) => {
        if (this.root.isInsideViewPort(step.offset.px, 1)) {
          lines.push({
            key: step.time,
            x1: step.offset.px,
            y1: 0,
            x2: step.offset.px,
            y2: state.tasks.length * (state.options.row.height + state.options.chart.grid.horizontal.gap * 2) + this.root.style["grid-line-vertical"]["stroke-width"]
          });
        }
      });
      return lines;
    },
    horizontalLines() {
      let lines = [];
      const state = this.root.state.options;
      let tasks = this.root.visibleTasks;
      for (let index2 = 0, len = tasks.length; index2 <= len; index2++) {
        const y2 = index2 * (state.row.height + state.chart.grid.horizontal.gap * 2) + this.root.style["grid-line-vertical"]["stroke-width"] / 2;
        lines.push({
          key: "hl" + index2,
          x1: 0,
          y1: y2,
          x2: "100%",
          y2
        });
      }
      return lines;
    },
    inViewPort() {
      return (line) => {
        const state = this.root.state.options;
        return line.x1 >= state.scroll.chart.left && line.x1 <= state.scroll.chart.right;
      };
    },
    timeLinePosition() {
      const d2 = /* @__PURE__ */ new Date();
      const current = d2.getTime();
      const currentOffset = this.root.timeToPixelOffsetX(current);
      const timeLine = {
        x: 0,
        y1: 0,
        y2: "100%",
        dateTime: "",
        time: current
      };
      timeLine.x = currentOffset;
      timeLine.dateTime = d2.toLocaleDateString();
      return timeLine;
    }
  }
};
var _hoisted_1$a = ["width", "height"];
var _hoisted_2$8 = ["x1", "y1", "x2", "y2"];
var _hoisted_3$7 = ["x1", "y1", "x2", "y2"];
var _hoisted_4$5 = ["x1", "y1", "x2", "y2"];
function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    class: "gantt-elastic__grid-lines-wrapper",
    style: normalizeStyle(__spreadValues({}, $options.root.style["grid-lines-wrapper"])),
    ref: "chart",
    x: "0",
    y: "0",
    width: $options.root.state.options.width,
    height: $options.root.state.options.allVisibleTasksHeight,
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    createBaseVNode("g", {
      class: "gantt-elastic__grid-lines",
      style: normalizeStyle(__spreadValues({}, $options.root.style["grid-lines"]))
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList($options.horizontalLines, (line) => {
        return openBlock(), createElementBlock("line", {
          class: "gantt-elastic__grid-line-horizontal",
          style: normalizeStyle(__spreadValues({}, $options.root.style["grid-line-horizontal"])),
          key: line.key,
          x1: line.x1,
          y1: line.y1,
          x2: line.x2,
          y2: line.y2
        }, null, 12, _hoisted_2$8);
      }), 128)),
      (openBlock(true), createElementBlock(Fragment, null, renderList($options.verticalLines, (line) => {
        return openBlock(), createElementBlock("line", {
          class: "gantt-elastic__grid-line-vertical",
          style: normalizeStyle(__spreadValues({}, $options.root.style["grid-line-vertical"])),
          key: line.key,
          x1: line.x1,
          y1: line.y1,
          x2: line.x2,
          y2: line.y2
        }, null, 12, _hoisted_3$7);
      }), 128)),
      createBaseVNode("line", {
        class: "gantt-elastic__grid-line-time",
        style: normalizeStyle(__spreadValues({}, $options.root.style["grid-line-time"])),
        x1: $options.timeLinePosition.x,
        y1: $options.timeLinePosition.y1,
        x2: $options.timeLinePosition.x,
        y2: $options.timeLinePosition.y2
      }, null, 12, _hoisted_4$5)
    ], 4)
  ], 12, _hoisted_1$a);
}
var Grid = _export_sfc(_sfc_main$d, [["render", _sfc_render$d]]);
var _sfc_main$c = {
  name: "DaysHighlight",
  inject: ["root"],
  data() {
    return {};
  },
  methods: {
    getKey(day) {
      return dayjs(day.time).format("YYYY-MM-DD");
    }
  },
  computed: {
    workingDays() {
      return this.root.state.options.times.steps.filter((step) => {
        return this.root.state.options.calendar.workingDays.indexOf(dayjs(step.time).day()) === -1;
      });
    },
    showWorkingDays() {
      const calendar = this.root.state.options.calendar;
      if (typeof calendar.workingDays !== "undefined" && Array.isArray(calendar.workingDays) && calendar.workingDays.length) {
        return true;
      }
      return false;
    }
  }
};
var _hoisted_1$9 = ["x", "width"];
function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
  return $options.showWorkingDays ? (openBlock(), createElementBlock("g", {
    key: 0,
    class: "gantt-elastic__chart-days-highlight-container",
    style: normalizeStyle(__spreadValues({}, $options.root.style["chart-days-highlight-container"]))
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList($options.workingDays, (day) => {
      return openBlock(), createElementBlock("rect", {
        class: "gantt-elastic__chart-days-highlight-rect",
        key: $options.getKey(day),
        x: day.offset.px,
        y: "0",
        width: day.width.px,
        height: "100%",
        style: normalizeStyle(__spreadValues({}, $options.root.style["chart-days-highlight-rect"]))
      }, null, 12, _hoisted_1$9);
    }), 128))
  ], 4)) : createCommentVNode("", true);
}
var DaysHighlight = _export_sfc(_sfc_main$c, [["render", _sfc_render$c]]);
var _sfc_main$b = {
  name: "CalendarRow",
  inject: ["root"],
  props: ["items", "which"],
  data() {
    return {};
  },
  methods: {
    getTextX(item) {
      let x2 = item.x + item.width / 2 - item.textWidth / 2;
      if (this.which === "month" && this.root.isInsideViewPort(item.x, item.width, 0)) {
        let scrollWidth = this.root.state.options.scroll.chart.right - this.root.state.options.scroll.chart.left;
        x2 = this.root.state.options.scroll.chart.left + scrollWidth / 2 - item.textWidth / 2 + 2;
        if (x2 + item.textWidth + 2 > item.x + item.width) {
          x2 = item.x + item.width - item.textWidth - 2;
        } else if (x2 < item.x) {
          x2 = item.x + 2;
        }
      }
      return x2 - item.x;
    }
  },
  computed: {
    rowStyle() {
      return __spreadValues(__spreadValues({}, this.root.style["calendar-row"]), this.root.style["calendar-row--" + this.which]);
    },
    rectStyle() {
      return __spreadValues(__spreadValues({}, this.root.style["calendar-row-rect"]), this.root.style["calendar-row-rect--" + this.which]);
    },
    rectChildStyle() {
      const basicStyle = __spreadValues(__spreadValues({}, this.root.style["calendar-row-rect-child"]), this.root.style["calendar-row-rect-child--" + this.which]);
      const style = [];
      for (let item of this.items) {
        const childrenStyle = [];
        for (let child of item.children) {
          childrenStyle.push(__spreadProps(__spreadValues({}, basicStyle), {
            width: child.width + "px",
            height: child.height + "px"
          }));
        }
        style.push(childrenStyle);
      }
      return style;
    },
    textStyle() {
      const basicStyle = __spreadValues(__spreadValues({}, this.root.style["calendar-row-text"]), this.root.style["calendar-row-text--" + this.which]);
      return (child) => {
        const style = __spreadValues({}, basicStyle);
        if (this.which === "month") {
          style.left = this.getTextX(child) + "px";
        }
        return style;
      };
    }
  }
};
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass("gantt-elastic__calendar-row gantt-elastic__calendar-row--" + $props.which),
    style: normalizeStyle($options.rowStyle)
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList($props.items, (item, itemIndex) => {
      return openBlock(), createElementBlock("div", {
        key: item.key,
        class: normalizeClass("gantt-elastic__calendar-row-rect gantt-elastic__calendar-row-rect--" + $props.which),
        style: normalizeStyle($options.rectStyle)
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(item.children, (child, childIndex) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass("gantt-elastic__calendar-row-rect-child gantt-elastic__calendar-row-rect-child--" + $props.which),
            key: child.key,
            style: normalizeStyle($options.rectChildStyle[itemIndex][childIndex])
          }, [
            createBaseVNode("div", {
              class: normalizeClass("gantt-elastic__calendar-row-text gantt-elastic__calendar-row-text--" + $props.which),
              style: normalizeStyle($options.textStyle(child))
            }, toDisplayString(child.label), 7)
          ], 6);
        }), 128))
      ], 6);
    }), 128))
  ], 6);
}
var CalendarRow = _export_sfc(_sfc_main$b, [["render", _sfc_render$b]]);
var _sfc_main$a = {
  name: "Calendar",
  components: {
    CalendarRow
  },
  inject: ["root"],
  data() {
    return {};
  },
  methods: {
    howManyHoursFit(dayIndex) {
      const stroke = 1;
      const additionalSpace = stroke + 2;
      let fullCellWidth = this.root.state.options.times.steps[dayIndex].width.px;
      let formatNames = Object.keys(this.root.state.options.calendar.hour.format);
      for (let hours = 24; hours > 1; hours = Math.ceil(hours / 2)) {
        for (let formatName of formatNames) {
          if ((this.root.state.options.calendar.hour.maxWidths[formatName] + additionalSpace) * hours <= fullCellWidth && hours > 1) {
            return {
              count: hours,
              type: formatName
            };
          }
        }
      }
      return {
        count: 0,
        type: ""
      };
    },
    howManyDaysFit() {
      const stroke = 1;
      const additionalSpace = stroke + 2;
      let fullWidth = this.root.state.options.width;
      let formatNames = Object.keys(this.root.state.options.calendar.day.format);
      for (let days = this.root.state.options.times.steps.length; days > 1; days = Math.ceil(days / 2)) {
        for (let formatName of formatNames) {
          if ((this.root.state.options.calendar.day.maxWidths[formatName] + additionalSpace) * days <= fullWidth && days > 1) {
            return {
              count: days,
              type: formatName
            };
          }
        }
      }
      return {
        count: 0,
        type: ""
      };
    },
    howManyMonthsFit() {
      const stroke = 1;
      const additionalSpace = stroke + 2;
      let fullWidth = this.root.state.options.width;
      let formatNames = Object.keys(this.root.state.options.calendar.month.format);
      let currentMonth = dayjs(this.root.state.options.times.firstTime);
      currentMonth.clone();
      this.root.state.options.times.lastTime;
      let monthsCount = this.root.monthsCount(this.root.state.options.times.firstTime, this.root.state.options.times.lastTime);
      if (monthsCount === 1) {
        for (let formatName of formatNames) {
          if (this.root.state.options.calendar.month.maxWidths[formatName] + additionalSpace <= fullWidth) {
            return {
              count: 1,
              type: formatName
            };
          }
        }
      }
      for (let months = monthsCount; months > 1; months = Math.ceil(months / 2)) {
        for (let formatName of formatNames) {
          if ((this.root.state.options.calendar.month.maxWidths[formatName] + additionalSpace) * months <= fullWidth && months > 1) {
            return {
              count: months,
              type: formatName
            };
          }
        }
      }
      return {
        count: 0,
        type: formatNames[0]
      };
    },
    generateHours() {
      let allHours = [];
      if (!this.root.state.options.calendar.hour.display) {
        return allHours;
      }
      const steps = this.root.state.options.times.steps;
      this.root.state.options.locale.name;
      for (let hourIndex = 0, len = steps.length; hourIndex < len; hourIndex++) {
        const hoursCount = this.howManyHoursFit(hourIndex);
        if (hoursCount.count === 0) {
          continue;
        }
        const hours = { key: hourIndex + "step", children: [] };
        const hourStep = 24 / hoursCount.count;
        const hourWidthPx = steps[hourIndex].width.px / hoursCount.count;
        for (let i = 0, len2 = hoursCount.count; i < len2; i++) {
          const hour = i * hourStep;
          let index2 = hourIndex;
          if (hourIndex > 0) {
            index2 = hourIndex - Math.floor(hourIndex / 24) * 24;
          }
          let textWidth = 0;
          if (typeof this.root.state.options.calendar.hour.widths[index2] !== "undefined") {
            textWidth = this.root.state.options.calendar.hour.widths[index2][hoursCount.type];
          }
          let x2 = steps[hourIndex].offset.px + hourWidthPx * i;
          hours.children.push({
            index: hourIndex,
            key: "h" + i,
            x: x2,
            y: this.root.state.options.calendar.day.height + this.root.state.options.calendar.month.height,
            width: hourWidthPx,
            textWidth,
            height: this.root.state.options.calendar.hour.height,
            label: this.root.state.options.calendar.hour.formatted[hoursCount.type][hour]
          });
        }
        allHours.push(hours);
      }
      return allHours;
    },
    generateDays() {
      let days = [];
      if (!this.root.state.options.calendar.day.display) {
        return days;
      }
      const daysCount = this.howManyDaysFit();
      if (daysCount.count === 0) {
        return days;
      }
      const steps = this.root.state.options.times.steps;
      const localeName = this.root.state.options.locale.name;
      const dayStep = Math.ceil(steps.length / daysCount.count);
      for (let dayIndex = 0, len = steps.length; dayIndex < len; dayIndex += dayStep) {
        let dayWidthPx = 0;
        for (let currentStep = 0; currentStep < dayStep; currentStep++) {
          if (typeof steps[dayIndex + currentStep] !== "undefined") {
            dayWidthPx += steps[dayIndex + currentStep].width.px;
          }
        }
        const date = dayjs(steps[dayIndex].time);
        let textWidth = 0;
        if (typeof this.root.state.options.calendar.day.widths[dayIndex] !== "undefined") {
          textWidth = this.root.state.options.calendar.day.widths[dayIndex][daysCount.type];
        }
        let x2 = steps[dayIndex].offset.px;
        days.push({
          index: dayIndex,
          key: steps[dayIndex].time + "d",
          x: x2,
          y: this.root.state.options.calendar.month.height,
          width: dayWidthPx,
          textWidth,
          height: this.root.state.options.calendar.day.height,
          label: this.root.state.options.calendar.day.format[daysCount.type](date.locale(localeName))
        });
      }
      return days.map((item) => ({
        key: item.key,
        children: [item]
      }));
    },
    generateMonths() {
      let months = [];
      if (!this.root.state.options.calendar.month.display) {
        return months;
      }
      const monthsCount = this.howManyMonthsFit();
      if (monthsCount.count === 0) {
        return months;
      }
      this.root.state.options.times.steps;
      const localeName = this.root.state.options.locale.name;
      let formatNames = Object.keys(this.root.state.options.calendar.month.format);
      let currentDate = dayjs(this.root.state.options.times.firstTime);
      for (let monthIndex = 0; monthIndex < monthsCount.count; monthIndex++) {
        let monthWidth = 0;
        let monthOffset = Number.MAX_SAFE_INTEGER;
        let finalDate = dayjs(currentDate).add(1, "month").startOf("month");
        if (finalDate.valueOf() > this.root.state.options.times.lastTime) {
          finalDate = dayjs(this.root.state.options.times.lastTime);
        }
        for (let step = 0, len = this.root.state.options.times.steps.length; step < len; step++) {
          let currentStep = this.root.state.options.times.steps[step];
          if (currentStep.time >= currentDate.valueOf() && currentStep.time < finalDate.valueOf()) {
            monthWidth += currentStep.width.px;
            if (currentStep.offset.px < monthOffset) {
              monthOffset = currentStep.offset.px;
            }
          }
        }
        let label = "";
        let choosenFormatName;
        for (let formatName of formatNames) {
          if (this.root.state.options.calendar.month.maxWidths[formatName] + 2 <= monthWidth) {
            label = this.root.state.options.calendar.month.format[formatName](currentDate.locale(localeName));
            choosenFormatName = formatName;
          }
        }
        let textWidth = 0;
        if (typeof this.root.state.options.calendar.month.widths[monthIndex] !== "undefined") {
          textWidth = this.root.state.options.calendar.month.widths[monthIndex][choosenFormatName];
        }
        let x2 = monthOffset;
        months.push({
          index: monthIndex,
          key: monthIndex + "m",
          x: x2,
          y: 0,
          width: monthWidth,
          textWidth,
          choosenFormatName,
          height: this.root.state.options.calendar.month.height,
          label
        });
        currentDate = currentDate.add(1, "month").startOf("month");
        if (currentDate.valueOf() > this.root.state.options.times.lastTime) {
          currentDate = dayjs(this.root.state.options.times.lastTime);
        }
      }
      return months.map((item) => ({
        key: item.key,
        children: [item]
      }));
    },
    calculateCalendarDimensions({ hours, days, months }) {
      let height = 0;
      if (this.root.state.options.calendar.hour.display && hours.length > 0) {
        height += this.root.state.options.calendar.hour.height;
      }
      if (this.root.state.options.calendar.day.display && days.length > 0) {
        height += this.root.state.options.calendar.day.height;
      }
      if (this.root.state.options.calendar.month.display && months.length > 0) {
        height += this.root.state.options.calendar.month.height;
      }
      this.root.state.options.calendar.height = height;
    }
  },
  computed: {
    dates() {
      const hours = this.generateHours();
      const days = this.generateDays();
      const months = this.generateMonths();
      const allDates = { hours, days, months };
      this.calculateCalendarDimensions(allDates);
      return allDates;
    }
  }
};
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_calendar_row = resolveComponent("calendar-row");
  return openBlock(), createElementBlock("div", {
    class: "gantt-elastic__calendar-wrapper",
    style: normalizeStyle(__spreadProps(__spreadValues({}, $options.root.style["calendar-wrapper"]), { width: $options.root.state.options.width + "px" }))
  }, [
    createBaseVNode("div", {
      class: "gantt-elastic__calendar",
      style: normalizeStyle(__spreadProps(__spreadValues({}, $options.root.style["calendar"]), { width: $options.root.state.options.width + "px" }))
    }, [
      $options.root.state.options.calendar.month.display ? (openBlock(), createBlock(_component_calendar_row, {
        key: 0,
        items: $options.dates.months,
        which: "month"
      }, null, 8, ["items"])) : createCommentVNode("", true),
      $options.root.state.options.calendar.day.display ? (openBlock(), createBlock(_component_calendar_row, {
        key: 1,
        items: $options.dates.days,
        which: "day"
      }, null, 8, ["items"])) : createCommentVNode("", true),
      $options.root.state.options.calendar.hour.display ? (openBlock(), createBlock(_component_calendar_row, {
        key: 2,
        items: $options.dates.hours,
        which: "hour"
      }, null, 8, ["items"])) : createCommentVNode("", true)
    ], 4)
  ], 4);
}
var Calendar = _export_sfc(_sfc_main$a, [["render", _sfc_render$a]]);
var _sfc_main$9 = {
  name: "DependencyLines",
  inject: ["root"],
  props: ["tasks"],
  data() {
    return {};
  },
  methods: {
    getPoints(fromTaskId, toTaskId) {
      const fromTask = this.root.getTask(fromTaskId);
      const toTask = this.root.getTask(toTaskId);
      if (fromTask === null || toTask === null || !this.root.isTaskVisible(toTask) || !this.root.isTaskVisible(fromTask)) {
        return null;
      }
      const startX = fromTask.x + fromTask.width;
      const startY = fromTask.y + fromTask.height / 2;
      const stopX = toTask.x;
      const stopY = toTask.y + toTask.height / 2;
      const distanceX = stopX - startX;
      let distanceY;
      let yMultiplier = 1;
      if (stopY >= startY) {
        distanceY = stopY - startY;
      } else {
        distanceY = startY - stopY;
        yMultiplier = -1;
      }
      const offset = 10;
      const roundness = 4;
      const isBefore = distanceX <= offset + roundness;
      let points = `M ${startX} ${startY}
          L ${startX + offset},${startY} `;
      if (isBefore) {
        points += `Q ${startX + offset + roundness},${startY} ${startX + offset + roundness},${startY + roundness * yMultiplier}
            L ${startX + offset + roundness},${startY + distanceY * yMultiplier / 2 - roundness * yMultiplier}
            Q ${startX + offset + roundness},${startY + distanceY * yMultiplier / 2} ${startX + offset},${startY + distanceY * yMultiplier / 2}
            L ${startX - offset + distanceX},${startY + distanceY * yMultiplier / 2}
            Q ${startX - offset + distanceX - roundness},${startY + distanceY * yMultiplier / 2} ${startX - offset + distanceX - roundness},${startY + distanceY * yMultiplier / 2 + roundness * yMultiplier}
            L ${startX - offset + distanceX - roundness},${stopY - roundness * yMultiplier}
            Q ${startX - offset + distanceX - roundness},${stopY} ${startX - offset + distanceX},${stopY}
            L ${stopX},${stopY}`;
      } else {
        points += `L ${startX + distanceX / 2 - roundness},${startY}
            Q ${startX + distanceX / 2},${startY} ${startX + distanceX / 2},${startY + roundness * yMultiplier}
            L ${startX + distanceX / 2},${stopY - roundness * yMultiplier}
            Q ${startX + distanceX / 2},${stopY} ${startX + distanceX / 2 + roundness},${stopY}
            L ${stopX},${stopY}`;
      }
      return points;
    }
  },
  computed: {
    dependencyTasks() {
      return this.tasks.filter((task) => typeof task.dependentOn !== "undefined").map((task) => {
        task.dependencyLines = task.dependentOn.map((id) => {
          return { points: this.getPoints(id, task.id), task_id: id };
        });
        return task;
      }).filter((task) => task.dependencyLines.points !== null);
    }
  }
};
var _hoisted_1$8 = ["task"];
var _hoisted_2$7 = ["task", "d"];
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    x: "0",
    y: "0",
    width: "100%",
    height: "100%",
    class: "gantt-elastic__chart-dependency-lines-container",
    style: normalizeStyle(__spreadValues({}, $options.root.style["chart-dependency-lines-container"]))
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList($options.dependencyTasks, (task) => {
      return openBlock(), createElementBlock("g", {
        key: task.id,
        task
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(task.dependencyLines, (dependencyLine) => {
          return openBlock(), createElementBlock("path", {
            class: "gantt-elastic__chart-dependency-lines-path",
            style: normalizeStyle(__spreadValues(__spreadValues(__spreadValues({}, $options.root.style["chart-dependency-lines-path"]), task.style["chart-dependency-lines-path"]), task.style["chart-dependency-lines-path-" + dependencyLine.task_id])),
            key: dependencyLine.id,
            task,
            d: dependencyLine.points
          }, null, 12, _hoisted_2$7);
        }), 128))
      ], 8, _hoisted_1$8);
    }), 128))
  ], 4);
}
var DependencyLines = _export_sfc(_sfc_main$9, [["render", _sfc_render$9]]);
var _sfc_main$8 = {
  name: "ChartText",
  inject: ["root"],
  props: ["task"],
  data() {
    return {};
  },
  computed: {
    getWidth() {
      const textStyle = this.root.style["chart-row-text"];
      this.root.state.ctx.font = `${textStyle["font-weight"]} ${textStyle["font-size"]} ${textStyle["font-family"]}`;
      const textWidth = this.root.state.ctx.measureText(this.task.label).width;
      return textWidth + this.root.state.options.chart.text.xPadding * 2;
    },
    getHeight() {
      return this.task.height + this.root.state.options.chart.grid.horizontal.gap * 2;
    },
    contentStyle() {
      return { height: "100%", "line-height": this.getHeight + "px" };
    },
    html() {
      const cols = this.root.state.options.taskList.columns;
      for (let i = 0, len = cols.length; i < len; i++) {
        const col = cols[i];
        if (col.value === "label" && typeof col.html !== "undefined" && col.html) {
          return true;
        }
      }
      return false;
    }
  }
};
var _hoisted_1$7 = ["x", "y", "width", "height"];
var _hoisted_2$6 = ["height"];
var _hoisted_3$6 = ["innerHTML"];
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    class: "gantt-elastic__chart-row-text-wrapper",
    style: normalizeStyle(__spreadValues({}, $options.root.style["chart-row-text-wrapper"])),
    x: $props.task.x + $props.task.width + $options.root.state.options.chart.text.offset,
    y: $props.task.y - $options.root.state.options.chart.grid.horizontal.gap,
    width: $options.getWidth,
    height: $options.getHeight
  }, [
    (openBlock(), createElementBlock("foreignObject", {
      x: "0",
      y: "0",
      width: "100%",
      height: $options.getHeight
    }, [
      createBaseVNode("div", {
        xmlns: "http://www.w3.org/1999/xhtml",
        class: "gantt-elastic__chart-row-text",
        style: normalizeStyle(__spreadValues({}, $options.root.style["chart-row-text"]))
      }, [
        !$options.html ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "gantt-elastic__chart-row-text-content gantt-elastic__chart-row-text-content--text",
          style: normalizeStyle(__spreadValues(__spreadValues(__spreadValues({}, $options.root.style["chart-row-text-content"]), $options.root.style["chart-row-text-content--text"]), $options.contentStyle))
        }, [
          createBaseVNode("div", null, toDisplayString($props.task.label), 1)
        ], 4)) : createCommentVNode("", true),
        $options.html ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: "gantt-elastic__chart-row-text-content gantt-elastic__chart-row-text-content--html",
          style: normalizeStyle(__spreadValues(__spreadValues(__spreadValues({}, $options.root.style["chart-row-text-content"]), $options.root.style["chart-row-text-content--html"]), $options.contentStyle)),
          innerHTML: $props.task.label
        }, null, 12, _hoisted_3$6)) : createCommentVNode("", true)
      ], 4)
    ], 8, _hoisted_2$6))
  ], 12, _hoisted_1$7);
}
var ChartText = _export_sfc(_sfc_main$8, [["render", _sfc_render$8]]);
var _sfc_main$7 = {
  name: "ProgressBar",
  inject: ["root"],
  props: ["task"],
  data() {
    return {};
  },
  computed: {
    getProgressWidth() {
      return this.task.progress + "%";
    },
    getLinePoints() {
      const start = this.task.width / 100 * this.task.progress;
      return `M ${start} 0 L ${start} ${this.task.height}`;
    },
    getSolidStyle() {
      return Object.assign({}, this.root.state.options.chart.progress.styles.bar.solid, this.task.progressBarStyle.bar);
    },
    getLineStyle() {
      return Object.assign({}, {
        stroke: this.root.state.options.row.styles.bar.stroke + "a0",
        "stroke-width": this.root.state.options.row.styles.bar["stroke-width"] / 2
      }, this.task.style);
    }
  }
};
var _hoisted_1$6 = ["width", "height"];
var _hoisted_2$5 = ["y2"];
var _hoisted_3$5 = ["width"];
var _hoisted_4$4 = { key: 1 };
var _hoisted_5$4 = ["x", "width"];
var _hoisted_6$1 = ["d"];
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("g", {
    class: "gantt-elastic__chart-row-progress-bar-wrapper",
    style: normalizeStyle(__spreadValues(__spreadValues({}, $options.root.style["chart-row-progress-bar-wrapper"]), $props.task.style["chart-row-progress-bar-wrapper"]))
  }, [
    createBaseVNode("defs", null, [
      createBaseVNode("pattern", {
        id: "diagonalHatch",
        width: $options.root.state.options.chart.progress.width,
        height: $options.root.state.options.chart.progress.width,
        patternTransform: "rotate(45 0 0)",
        patternUnits: "userSpaceOnUse"
      }, [
        createBaseVNode("line", {
          class: "chart-row-progress-bar-line",
          style: normalizeStyle(__spreadValues(__spreadValues({}, $options.root.style["chart-row-progress-bar-line"]), $props.task.style["chart-row-progress-bar-line"])),
          x1: "0",
          y1: "0",
          x2: "0",
          y2: $options.root.state.options.chart.progress.width
        }, null, 12, _hoisted_2$5)
      ], 8, _hoisted_1$6)
    ]),
    $options.root.state.options.chart.progress.bar ? (openBlock(), createElementBlock("rect", {
      key: 0,
      class: "gantt-elastic__chart-row-progress-bar-solid",
      style: normalizeStyle(__spreadValues(__spreadValues({}, $options.root.style["chart-row-progress-bar-solid"]), $props.task.style["chart-row-progress-bar-solid"])),
      x: "0",
      y: "0",
      width: $options.getProgressWidth
    }, null, 12, _hoisted_3$5)) : createCommentVNode("", true),
    $options.root.state.options.chart.progress.pattern ? (openBlock(), createElementBlock("g", _hoisted_4$4, [
      createBaseVNode("rect", {
        class: "gantt-elastic__chart-row-progress-bar-pattern",
        style: normalizeStyle(__spreadValues(__spreadValues({}, $options.root.style["chart-row-progress-bar-pattern"]), $props.task.style["chart-row-progress-bar-pattern"])),
        x: $options.getProgressWidth,
        y: "0",
        width: 100 - $props.task.progress + "%",
        height: "100%"
      }, null, 12, _hoisted_5$4),
      createBaseVNode("path", {
        class: "gantt-elastic__chart-row-progress-bar-outline",
        style: normalizeStyle(__spreadValues(__spreadValues(__spreadValues({}, $options.root.style["chart-row-progress-bar-outline"]), $props.task.style["base"]), $props.task.style["chart-row-progress-bar-outline"])),
        d: $options.getLinePoints
      }, null, 12, _hoisted_6$1)
    ])) : createCommentVNode("", true)
  ], 4);
}
var ProgressBar = _export_sfc(_sfc_main$7, [["render", _sfc_render$7]]);
var taskMixin = {
  computed: {
    getViewBox() {
      const task = this.task;
      return `0 0 ${task.width} ${task.height}`;
    },
    getGroupTransform() {
      return `translate(${this.task.x} ${this.task.y})`;
    },
    displayExpander() {
      const expander = this.root.state.options.chart.expander;
      return expander.display || expander.displayIfTaskListHidden && !this.root.state.options.taskList.display;
    }
  },
  methods: {
    emitEvent(eventName, event) {
      if (!this.root.state.options.scroll.scrolling) {
        this.root.$emit(`chart-${this.task.type}-${eventName}`, { event, data: this.task });
      }
    }
  }
};
var _sfc_main$6 = {
  name: "Task",
  components: {
    ChartText,
    ProgressBar,
    Expander
  },
  inject: ["root"],
  props: ["task"],
  mixins: [taskMixin],
  data() {
    return {};
  },
  computed: {
    clipPathId() {
      return "gantt-elastic__task-clip-path-" + this.task.id;
    },
    getPoints() {
      const task = this.task;
      return `0,0 ${task.width},0 ${task.width},${task.height} 0,${task.height}`;
    }
  }
};
var _hoisted_1$5 = ["x", "y", "width", "height"];
var _hoisted_2$4 = ["x", "y", "width", "height", "viewBox"];
var _hoisted_3$4 = ["id"];
var _hoisted_4$3 = ["points"];
var _hoisted_5$3 = ["points"];
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_expander = resolveComponent("expander");
  const _component_progress_bar = resolveComponent("progress-bar");
  const _component_chart_text = resolveComponent("chart-text");
  return openBlock(), createElementBlock("g", {
    class: "gantt-elastic__chart-row-bar-wrapper gantt-elastic__chart-row-task-wrapper",
    style: normalizeStyle(__spreadValues(__spreadValues(__spreadValues({}, $options.root.style["chart-row-bar-wrapper"]), $options.root.style["chart-row-task-wrapper"]), $props.task.style["chart-row-bar-wrapper"]))
  }, [
    _ctx.displayExpander ? (openBlock(), createElementBlock("foreignObject", {
      key: 0,
      class: "gantt-elastic__chart-expander gantt-elastic__chart-expander--task",
      style: normalizeStyle(__spreadValues(__spreadValues(__spreadValues({}, $options.root.style["chart-expander"]), $options.root.style["chart-expander--task"]), $props.task.style["chart-expander"])),
      x: $props.task.x - $options.root.state.options.chart.expander.offset - $options.root.state.options.chart.expander.size,
      y: $props.task.y + ($options.root.state.options.row.height - $options.root.state.options.chart.expander.size) / 2,
      width: $options.root.state.options.chart.expander.size,
      height: $options.root.state.options.chart.expander.size
    }, [
      createVNode(_component_expander, {
        tasks: [$props.task],
        options: $options.root.state.options.chart.expander,
        type: "chart"
      }, null, 8, ["tasks", "options"])
    ], 12, _hoisted_1$5)) : createCommentVNode("", true),
    (openBlock(), createElementBlock("svg", {
      class: "gantt-elastic__chart-row-bar gantt-elastic__chart-row-task",
      style: normalizeStyle(__spreadValues(__spreadValues(__spreadValues({}, $options.root.style["chart-row-bar"]), $options.root.style["chart-row-task"]), $props.task.style["chart-row-bar"])),
      x: $props.task.x,
      y: $props.task.y,
      width: $props.task.width,
      height: $props.task.height,
      viewBox: `0 0 ${$props.task.width} ${$props.task.height}`,
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.emitEvent("click", $event)),
      onMouseenter: _cache[1] || (_cache[1] = ($event) => _ctx.emitEvent("mouseenter", $event)),
      onMouseover: _cache[2] || (_cache[2] = ($event) => _ctx.emitEvent("mouseover", $event)),
      onMouseout: _cache[3] || (_cache[3] = ($event) => _ctx.emitEvent("mouseout", $event)),
      onMousemove: _cache[4] || (_cache[4] = ($event) => _ctx.emitEvent("mousemove", $event)),
      onMousedown: _cache[5] || (_cache[5] = ($event) => _ctx.emitEvent("mousedown", $event)),
      onMouseup: _cache[6] || (_cache[6] = ($event) => _ctx.emitEvent("mouseup", $event)),
      onMousewheel: _cache[7] || (_cache[7] = ($event) => _ctx.emitEvent("mousewheel", $event)),
      onTouchstart: _cache[8] || (_cache[8] = ($event) => _ctx.emitEvent("touchstart", $event)),
      onTouchmove: _cache[9] || (_cache[9] = ($event) => _ctx.emitEvent("touchmove", $event)),
      onTouchend: _cache[10] || (_cache[10] = ($event) => _ctx.emitEvent("touchend", $event)),
      xmlns: "http://www.w3.org/2000/svg"
    }, [
      createBaseVNode("defs", null, [
        createBaseVNode("clipPath", { id: $options.clipPathId }, [
          createBaseVNode("polygon", { points: $options.getPoints }, null, 8, _hoisted_4$3)
        ], 8, _hoisted_3$4)
      ]),
      createBaseVNode("polygon", {
        class: "gantt-elastic__chart-row-bar-polygon gantt-elastic__chart-row-task-polygon",
        style: normalizeStyle(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, $options.root.style["chart-row-bar-polygon"]), $options.root.style["chart-row-task-polygon"]), $props.task.style["base"]), $props.task.style["chart-row-bar-polygon"])),
        points: $options.getPoints
      }, null, 12, _hoisted_5$3),
      createVNode(_component_progress_bar, {
        task: $props.task,
        "clip-path": "url(#" + $options.clipPathId + ")"
      }, null, 8, ["task", "clip-path"])
    ], 44, _hoisted_2$4)),
    $options.root.state.options.chart.text.display ? (openBlock(), createBlock(_component_chart_text, {
      key: 1,
      task: $props.task
    }, null, 8, ["task"])) : createCommentVNode("", true)
  ], 4);
}
var Task = _export_sfc(_sfc_main$6, [["render", _sfc_render$6]]);
var _sfc_main$5 = {
  name: "Milestone",
  components: {
    ChartText,
    ProgressBar,
    Expander
  },
  inject: ["root"],
  props: ["task"],
  mixins: [taskMixin],
  data() {
    return {};
  },
  computed: {
    clipPathId() {
      return "gantt-elastic__milestone-clip-path-" + this.task.id;
    },
    getPoints() {
      const task = this.task;
      const fifty = task.height / 2;
      let offset = fifty;
      if (task.width / 2 - offset < 0) {
        offset = task.width / 2;
      }
      return `0,${fifty}
        ${offset},0
        ${task.width - offset},0
        ${task.width},${fifty}
        ${task.width - offset},${task.height}
        ${offset},${task.height}`;
    }
  }
};
var _hoisted_1$4 = ["x", "y", "width", "height"];
var _hoisted_2$3 = ["x", "y", "width", "height", "viewBox"];
var _hoisted_3$3 = ["id"];
var _hoisted_4$2 = ["points"];
var _hoisted_5$2 = ["points"];
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_expander = resolveComponent("expander");
  const _component_progress_bar = resolveComponent("progress-bar");
  const _component_chart_text = resolveComponent("chart-text");
  return openBlock(), createElementBlock("g", {
    class: "gantt-elastic__chart-row-bar-wrapper gantt-elastic__chart-row-milestone-wrapper",
    style: normalizeStyle(__spreadValues(__spreadValues(__spreadValues({}, $options.root.style["chart-row-bar-wrapper"]), $options.root.style["chart-row-milestone-wrapper"]), $props.task.style["chart-row-bar-wrapper"]))
  }, [
    _ctx.displayExpander ? (openBlock(), createElementBlock("foreignObject", {
      key: 0,
      class: "gantt-elastic__chart-expander gantt-elastic__chart-expander--milestone",
      style: normalizeStyle(__spreadValues(__spreadValues(__spreadValues({}, $options.root.style["chart-expander"]), $options.root.style["chart-expander--milestone"]), $props.task.style["chart-expander"])),
      x: $props.task.x - $options.root.state.options.chart.expander.offset - $options.root.state.options.chart.expander.size,
      y: $props.task.y + ($options.root.state.options.row.height - $options.root.state.options.chart.expander.size) / 2,
      width: $options.root.state.options.chart.expander.size,
      height: $options.root.state.options.chart.expander.size
    }, [
      createVNode(_component_expander, {
        tasks: [$props.task],
        options: $options.root.state.options.chart.expander,
        type: "chart"
      }, null, 8, ["tasks", "options"])
    ], 12, _hoisted_1$4)) : createCommentVNode("", true),
    (openBlock(), createElementBlock("svg", {
      class: "gantt-elastic__chart-row-bar gantt-elastic__chart-row-milestone",
      style: normalizeStyle(__spreadValues(__spreadValues(__spreadValues({}, $options.root.style["chart-row-bar"]), $options.root.style["chart-row-milestone"]), $props.task.style["chart-row-bar"])),
      x: $props.task.x,
      y: $props.task.y,
      width: $props.task.width,
      height: $props.task.height,
      viewBox: `0 0 ${$props.task.width} ${$props.task.height}`,
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.emitEvent("click", $event)),
      onMouseenter: _cache[1] || (_cache[1] = ($event) => _ctx.emitEvent("mouseenter", $event)),
      onMouseover: _cache[2] || (_cache[2] = ($event) => _ctx.emitEvent("mouseover", $event)),
      onMouseout: _cache[3] || (_cache[3] = ($event) => _ctx.emitEvent("mouseout", $event)),
      onMousemove: _cache[4] || (_cache[4] = ($event) => _ctx.emitEvent("mousemove", $event)),
      onMousedown: _cache[5] || (_cache[5] = ($event) => _ctx.emitEvent("mousedown", $event)),
      onMouseup: _cache[6] || (_cache[6] = ($event) => _ctx.emitEvent("mouseup", $event)),
      onMousewheel: _cache[7] || (_cache[7] = ($event) => _ctx.emitEvent("mousewheel", $event)),
      onTouchstart: _cache[8] || (_cache[8] = ($event) => _ctx.emitEvent("touchstart", $event)),
      onTouchmove: _cache[9] || (_cache[9] = ($event) => _ctx.emitEvent("touchmove", $event)),
      onTouchend: _cache[10] || (_cache[10] = ($event) => _ctx.emitEvent("touchend", $event)),
      xmlns: "http://www.w3.org/2000/svg"
    }, [
      createBaseVNode("defs", null, [
        createBaseVNode("clipPath", { id: $options.clipPathId }, [
          createBaseVNode("polygon", { points: $options.getPoints }, null, 8, _hoisted_4$2)
        ], 8, _hoisted_3$3)
      ]),
      createBaseVNode("polygon", {
        class: "gantt-elastic__chart-row-bar-polygon gantt-elastic__chart-row-milestone-polygon",
        style: normalizeStyle(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, $options.root.style["chart-row-bar-polygon"]), $options.root.style["chart-row-milestone-polygon"]), $props.task.style["base"]), $props.task.style["chart-row-bar-polygon"])),
        points: $options.getPoints
      }, null, 12, _hoisted_5$2),
      createVNode(_component_progress_bar, {
        task: $props.task,
        "clip-path": "url(#" + $options.clipPathId + ")"
      }, null, 8, ["task", "clip-path"])
    ], 44, _hoisted_2$3)),
    $options.root.state.options.chart.text.display ? (openBlock(), createBlock(_component_chart_text, {
      key: 1,
      task: $props.task
    }, null, 8, ["task"])) : createCommentVNode("", true)
  ], 4);
}
var Milestone = _export_sfc(_sfc_main$5, [["render", _sfc_render$5]]);
var _sfc_main$4 = {
  name: "Project",
  components: {
    ChartText,
    ProgressBar,
    Expander
  },
  inject: ["root"],
  props: ["task"],
  mixins: [taskMixin],
  data() {
    return {};
  },
  computed: {
    clipPathId() {
      return "gantt-elastic__project-clip-path-" + this.task.id;
    },
    getPoints() {
      const task = this.task;
      const bottom = task.height - task.height / 4;
      const corner = task.height / 6;
      const smallCorner = task.height / 8;
      return `M ${smallCorner},0
                L ${task.width - smallCorner} 0
                L ${task.width} ${smallCorner}
                L ${task.width} ${bottom}
                L ${task.width - corner} ${task.height}
                L ${task.width - corner * 2} ${bottom}
                L ${corner * 2} ${bottom}
                L ${corner} ${task.height}
                L 0 ${bottom}
                L 0 ${smallCorner}
                Z
        `;
    },
    displayExpander() {
      const expander = this.root.state.options.chart.expander;
      return expander.display || expander.displayIfTaskListHidden && !this.root.state.options.taskList.display;
    }
  }
};
var _hoisted_1$3 = ["x", "y", "width", "height"];
var _hoisted_2$2 = ["x", "y", "width", "height", "viewBox"];
var _hoisted_3$2 = ["id"];
var _hoisted_4$1 = ["d"];
var _hoisted_5$1 = ["d"];
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_expander = resolveComponent("expander");
  const _component_progress_bar = resolveComponent("progress-bar");
  const _component_chart_text = resolveComponent("chart-text");
  return openBlock(), createElementBlock("g", {
    class: "gantt-elastic__chart-row-bar-wrapper gantt-elastic__chart-row-project-wrapper",
    style: normalizeStyle(__spreadValues(__spreadValues(__spreadValues({}, $options.root.style["chart-row-bar-wrapper"]), $options.root.style["chart-row-project-wrapper"]), $props.task.style["chart-row-bar-wrapper"]))
  }, [
    $options.displayExpander ? (openBlock(), createElementBlock("foreignObject", {
      key: 0,
      class: "gantt-elastic__chart-expander gantt-elastic__chart-expander--project",
      style: normalizeStyle(__spreadValues(__spreadValues(__spreadValues({}, $options.root.style["chart-expander"]), $options.root.style["chart-expander--project"]), $props.task.style["chart-expander"])),
      x: $props.task.x - $options.root.state.options.chart.expander.offset - $options.root.state.options.chart.expander.size,
      y: $props.task.y + ($options.root.state.options.row.height - $options.root.state.options.chart.expander.size) / 2,
      width: $options.root.state.options.chart.expander.size,
      height: $options.root.state.options.chart.expander.size
    }, [
      createVNode(_component_expander, {
        tasks: [$props.task],
        options: $options.root.state.options.chart.expander,
        type: "chart"
      }, null, 8, ["tasks", "options"])
    ], 12, _hoisted_1$3)) : createCommentVNode("", true),
    (openBlock(), createElementBlock("svg", {
      class: "gantt-elastic__chart-row-bar gantt-elastic__chart-row-project",
      style: normalizeStyle(__spreadValues(__spreadValues(__spreadValues({}, $options.root.style["chart-row-bar"]), $options.root.style["chart-row-project"]), $props.task.style["chart-row-bar"])),
      x: $props.task.x,
      y: $props.task.y,
      width: $props.task.width,
      height: $props.task.height,
      viewBox: `0 0 ${$props.task.width} ${$props.task.height}`,
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.emitEvent("click", $event)),
      onMouseenter: _cache[1] || (_cache[1] = ($event) => _ctx.emitEvent("mouseenter", $event)),
      onMouseover: _cache[2] || (_cache[2] = ($event) => _ctx.emitEvent("mouseover", $event)),
      onMouseout: _cache[3] || (_cache[3] = ($event) => _ctx.emitEvent("mouseout", $event)),
      onMousemove: _cache[4] || (_cache[4] = ($event) => _ctx.emitEvent("mousemove", $event)),
      onMousedown: _cache[5] || (_cache[5] = ($event) => _ctx.emitEvent("mousedown", $event)),
      onMouseup: _cache[6] || (_cache[6] = ($event) => _ctx.emitEvent("mouseup", $event)),
      onMousewheel: _cache[7] || (_cache[7] = ($event) => _ctx.emitEvent("mousewheel", $event)),
      onTouchstart: _cache[8] || (_cache[8] = ($event) => _ctx.emitEvent("touchstart", $event)),
      onTouchmove: _cache[9] || (_cache[9] = ($event) => _ctx.emitEvent("touchmove", $event)),
      onTouchend: _cache[10] || (_cache[10] = ($event) => _ctx.emitEvent("touchend", $event)),
      xmlns: "http://www.w3.org/2000/svg"
    }, [
      createBaseVNode("defs", null, [
        createBaseVNode("clipPath", { id: $options.clipPathId }, [
          createBaseVNode("path", { d: $options.getPoints }, null, 8, _hoisted_4$1)
        ], 8, _hoisted_3$2)
      ]),
      createBaseVNode("path", {
        class: "gantt-elastic__chart-row-bar-polygon gantt-elastic__chart-row-project-polygon",
        style: normalizeStyle(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, $options.root.style["chart-row-bar-polygon"]), $options.root.style["chart-row-project-polygon"]), $props.task.style["base"]), $props.task.style["chart-row-bar-polygon"])),
        d: $options.getPoints
      }, null, 12, _hoisted_5$1),
      createVNode(_component_progress_bar, {
        task: $props.task,
        "clip-path": "url(#" + $options.clipPathId + ")"
      }, null, 8, ["task", "clip-path"])
    ], 44, _hoisted_2$2)),
    $options.root.state.options.chart.text.display ? (openBlock(), createBlock(_component_chart_text, {
      key: 1,
      task: $props.task
    }, null, 8, ["task"])) : createCommentVNode("", true)
  ], 4);
}
var Project = _export_sfc(_sfc_main$4, [["render", _sfc_render$4]]);
var _sfc_main$3 = {
  name: "Chart",
  components: {
    Grid,
    DependencyLines,
    Calendar,
    Task,
    Milestone,
    Project,
    DaysHighlight
  },
  inject: ["root"],
  data() {
    return {
      moving: false
    };
  },
  mounted() {
    this.root.state.refs.chart = this.$refs.chart;
    this.root.state.refs.chartCalendarContainer = this.$refs.chartCalendarContainer;
    this.root.state.refs.chartGraphContainer = this.$refs.chartGraphContainer;
    this.root.state.refs.chartGraph = this.$refs.chartGraph;
    this.root.state.refs.chartGraphSvg = this.$refs.chartGraphSvg;
  },
  computed: {
    getViewBox() {
      return `0 0 ${this.root.state.options.width} ${this.root.state.options.allVisibleTasksHeight}`;
    }
  }
};
var _hoisted_1$2 = ["width", "height"];
var _hoisted_2$1 = ["task"];
var _hoisted_3$1 = ["task"];
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_calendar = resolveComponent("calendar");
  const _component_days_highlight = resolveComponent("days-highlight");
  const _component_grid = resolveComponent("grid");
  const _component_dependency_lines = resolveComponent("dependency-lines");
  return openBlock(), createElementBlock("div", {
    class: "gantt-elastic__chart",
    style: normalizeStyle(__spreadValues({}, $options.root.style["chart"])),
    ref: "chart"
  }, [
    createBaseVNode("div", {
      class: "gantt-elastic__chart-calendar-container",
      ref: "chartCalendarContainer",
      style: normalizeStyle(__spreadProps(__spreadValues({}, $options.root.style["chart-calendar-container"]), {
        height: $options.root.state.options.calendar.height + "px",
        "margin-bottom": $options.root.state.options.calendar.gap + "px"
      }))
    }, [
      createVNode(_component_calendar)
    ], 4),
    createBaseVNode("div", {
      class: "gantt-elastic__chart-graph-container",
      ref: "chartGraphContainer",
      style: normalizeStyle(__spreadProps(__spreadValues({}, $options.root.style["chart-graph-container"]), {
        height: $options.root.state.options.height - $options.root.state.options.calendar.height + "px"
      }))
    }, [
      createBaseVNode("div", {
        style: normalizeStyle(__spreadProps(__spreadValues({}, $options.root.style["chart-area"]), {
          width: $options.root.state.options.width + "px",
          height: $options.root.state.options.rowsHeight + "px"
        }))
      }, [
        createBaseVNode("div", {
          class: "gantt-elastic__chart-graph",
          ref: "chartGraph",
          style: normalizeStyle(__spreadProps(__spreadValues({}, $options.root.style["chart-graph"]), { height: "100%" }))
        }, [
          (openBlock(), createElementBlock("svg", {
            class: "gantt-elastic__chart-graph-svg",
            style: normalizeStyle(__spreadValues({}, $options.root.style["chart-graph-svg"])),
            ref: "chartGraphSvg",
            x: "0",
            y: "0",
            width: $options.root.state.options.width + "px",
            height: $options.root.state.options.allVisibleTasksHeight + "px",
            xmlns: "http://www.w3.org/2000/svg"
          }, [
            createVNode(_component_days_highlight),
            createVNode(_component_grid),
            createVNode(_component_dependency_lines, {
              tasks: $options.root.visibleTasks
            }, null, 8, ["tasks"]),
            (openBlock(true), createElementBlock(Fragment, null, renderList($options.root.visibleTasks, (task) => {
              return openBlock(), createElementBlock("g", null, [
                task.type == "multiple" && task.subTask.length > 0 ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(task.subTask, (subTask) => {
                  return openBlock(), createElementBlock("g", {
                    task: subTask,
                    class: "gantt-elastic__chart-row-wrapper",
                    style: normalizeStyle(__spreadValues({}, $options.root.style["chart-row-wrapper"])),
                    key: subTask.id
                  }, [
                    (openBlock(), createBlock(resolveDynamicComponent(subTask.type), { task: subTask }, null, 8, ["task"]))
                  ], 12, _hoisted_2$1);
                }), 128)) : (openBlock(), createElementBlock("g", {
                  class: "gantt-elastic__chart-row-wrapper",
                  style: normalizeStyle(__spreadValues({}, $options.root.style["chart-row-wrapper"])),
                  task,
                  key: task.id
                }, [
                  (openBlock(), createBlock(resolveDynamicComponent(task.type), { task }, null, 8, ["task"]))
                ], 12, _hoisted_3$1))
              ]);
            }), 256))
          ], 12, _hoisted_1$2))
        ], 4)
      ], 4)
    ], 4)
  ], 4);
}
var Chart = _export_sfc(_sfc_main$3, [["render", _sfc_render$3]]);
var _sfc_main$2 = {
  name: "MainView",
  components: {
    TaskList,
    Chart
  },
  inject: ["root"],
  data() {
    return {
      defs: "",
      mousePos: {
        x: 0,
        y: 0,
        movementX: 0,
        movementY: 0,
        lastX: 0,
        lastY: 0,
        positiveX: 0,
        positiveY: 0,
        currentX: 0,
        currentY: 0
      }
    };
  },
  mounted() {
    this.viewBoxWidth = this.$el.clientWidth;
    this.root.state.refs.mainView = this.$refs.mainView;
    this.root.state.refs.chartContainer = this.$refs.chartContainer;
    this.root.state.refs.taskList = this.$refs.taskList;
    this.root.state.refs.chartScrollContainerHorizontal = this.$refs.chartScrollContainerHorizontal;
    this.root.state.refs.chartScrollContainerVertical = this.$refs.chartScrollContainerVertical;
    document.addEventListener("mouseup", this.chartMouseUp.bind(this));
    document.addEventListener("mousemove", this.chartMouseMove.bind(this));
    document.addEventListener("touchmove", this.chartMouseMove.bind(this));
    document.addEventListener("touchend", this.chartMouseUp.bind(this));
  },
  computed: {
    getMarginLeft() {
      if (!this.root.state.options.taskList.display) {
        return "0px";
      }
      return this.root.state.options.taskList.finalWidth + "px";
    },
    verticalStyle() {
      return {
        width: this.root.state.options.scrollBarHeight + "px",
        height: this.root.state.options.rowsHeight + "px",
        "margin-top": this.root.state.options.calendar.height + this.root.state.options.calendar.gap + "px"
      };
    },
    getViewBox() {
      if (this.root.state.options.clientWidth) {
        return `0 0 ${this.root.state.options.clientWidth - this.root.state.options.scrollBarHeight} ${this.root.state.options.height}`;
      }
      return `0 0 0 ${this.root.state.options.height}`;
    }
  },
  methods: {
    mouseMove(event) {
      this.$root.emitter.emit("main-view-mousemove", event);
    },
    mouseUp(event) {
      this.$root.emitter.emit("main-view-mouseup", event);
      this.root.$emit("main-view-mouseup", event);
    },
    onHorizontalScroll(ev) {
      this.$root.emitter.emit("chart-scroll-horizontal", ev);
    },
    onVerticalScroll(ev) {
      this.$root.emitter.emit("chart-scroll-vertical", ev);
    },
    chartWheel(ev) {
      this.$root.emitter.emit("chart-wheel", ev);
    },
    chartMouseDown(ev) {
      if (typeof ev.touches !== "undefined") {
        this.mousePos.x = this.mousePos.lastX = ev.touches[0].screenX;
        this.mousePos.y = this.mousePos.lastY = ev.touches[0].screenY;
        this.mousePos.movementX = 0;
        this.mousePos.movementY = 0;
        this.mousePos.currentX = this.$refs.chartScrollContainerHorizontal.scrollLeft;
        this.mousePos.currentY = this.$refs.chartScrollContainerVertical.scrollTop;
      }
      this.root.state.options.scroll.scrolling = true;
    },
    chartMouseUp(ev) {
      this.root.state.options.scroll.scrolling = false;
    },
    chartMouseMove(ev) {
      if (this.root.state.options.scroll.scrolling) {
        ev.preventDefault();
        ev.stopImmediatePropagation();
        ev.stopPropagation();
        const touch = typeof ev.touches !== "undefined";
        let movementX, movementY;
        if (touch) {
          const screenX = ev.touches[0].screenX;
          const screenY = ev.touches[0].screenY;
          movementX = this.mousePos.x - screenX;
          movementY = this.mousePos.y - screenY;
          this.mousePos.lastX = screenX;
          this.mousePos.lastY = screenY;
        } else {
          movementX = ev.movementX;
          movementY = ev.movementY;
        }
        const horizontal = this.$refs.chartScrollContainerHorizontal;
        const vertical = this.$refs.chartScrollContainerVertical;
        let x2 = 0, y2 = 0;
        if (touch) {
          x2 = this.mousePos.currentX + movementX * this.root.state.options.scroll.dragXMoveMultiplier;
        } else {
          x2 = horizontal.scrollLeft - movementX * this.root.state.options.scroll.dragXMoveMultiplier;
        }
        horizontal.scrollLeft = x2;
        if (touch) {
          y2 = this.mousePos.currentY + movementY * this.root.state.options.scroll.dragYMoveMultiplier;
        } else {
          y2 = vertical.scrollTop - movementY * this.root.state.options.scroll.dragYMoveMultiplier;
        }
        vertical.scrollTop = y2;
      }
    }
  },
  unmounted() {
    document.removeEventListener("mouseup", this.chartMouseUp);
    document.removeEventListener("mousemove", this.chartMouseMove);
    document.removeEventListener("touchmove", this.chartMouseMove);
    document.removeEventListener("touchend", this.chartMouseUp);
  }
};
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_task_list = resolveComponent("task-list");
  const _component_chart = resolveComponent("chart");
  return openBlock(), createElementBlock("div", {
    class: "gantt-elastic__main-view",
    style: normalizeStyle(__spreadValues({}, $options.root.style["main-view"]))
  }, [
    createBaseVNode("div", {
      class: "gantt-elastic__main-container-wrapper",
      style: normalizeStyle(__spreadProps(__spreadValues({}, $options.root.style["main-container-wrapper"]), { height: $options.root.state.options.height + "px" }))
    }, [
      createBaseVNode("div", {
        class: "gantt-elastic__main-container",
        style: normalizeStyle(__spreadProps(__spreadValues({}, $options.root.style["main-container"]), {
          width: $options.root.state.options.clientWidth + "px",
          height: $options.root.state.options.height + "px"
        })),
        ref: "mainView"
      }, [
        createBaseVNode("div", {
          class: "gantt-elastic__container",
          style: normalizeStyle(__spreadValues({}, $options.root.style["container"])),
          onMousemove: _cache[7] || (_cache[7] = (...args) => $options.mouseMove && $options.mouseMove(...args)),
          onMouseup: _cache[8] || (_cache[8] = (...args) => $options.mouseUp && $options.mouseUp(...args))
        }, [
          withDirectives(createBaseVNode("div", {
            ref: "taskList",
            class: "gantt-elastic__task-list-container",
            style: normalizeStyle(__spreadProps(__spreadValues({}, $options.root.style["task-list-container"]), {
              width: $options.root.state.options.taskList.finalWidth + "px",
              height: $options.root.state.options.height + "px"
            }))
          }, [
            createVNode(_component_task_list)
          ], 4), [
            [vShow, $options.root.state.options.taskList.display]
          ]),
          createBaseVNode("div", {
            class: "gantt-elastic__main-view-container",
            style: normalizeStyle(__spreadValues({}, $options.root.style["main-view-container"])),
            ref: "chartContainer",
            onMousedown: _cache[0] || (_cache[0] = (...args) => $options.chartMouseDown && $options.chartMouseDown(...args)),
            onTouchstart: _cache[1] || (_cache[1] = (...args) => $options.chartMouseDown && $options.chartMouseDown(...args)),
            onMouseup: _cache[2] || (_cache[2] = (...args) => $options.chartMouseUp && $options.chartMouseUp(...args)),
            onTouchend: _cache[3] || (_cache[3] = (...args) => $options.chartMouseUp && $options.chartMouseUp(...args)),
            onMousemove: _cache[4] || (_cache[4] = withModifiers((...args) => $options.chartMouseMove && $options.chartMouseMove(...args), ["prevent"])),
            onTouchmove: _cache[5] || (_cache[5] = withModifiers((...args) => $options.chartMouseMove && $options.chartMouseMove(...args), ["prevent"])),
            onWheel: _cache[6] || (_cache[6] = withModifiers((...args) => $options.chartWheel && $options.chartWheel(...args), ["prevent"]))
          }, [
            createVNode(_component_chart)
          ], 36)
        ], 36)
      ], 4),
      createBaseVNode("div", {
        class: "gantt-elastic__chart-scroll-container gantt-elastic__chart-scroll-container--vertical",
        style: normalizeStyle(__spreadValues(__spreadValues(__spreadValues({}, $options.root.style["chart-scroll-container"]), $options.root.style["chart-scroll-container--vertical"]), $options.verticalStyle)),
        ref: "chartScrollContainerVertical",
        onScroll: _cache[9] || (_cache[9] = (...args) => $options.onVerticalScroll && $options.onVerticalScroll(...args))
      }, [
        createBaseVNode("div", {
          class: "gantt-elastic__chart-scroll--vertical",
          style: normalizeStyle({ width: "1px", height: $options.root.state.options.allVisibleTasksHeight + "px" })
        }, null, 4)
      ], 36)
    ], 4),
    createBaseVNode("div", {
      class: "gantt-elastic__chart-scroll-container gantt-elastic__chart-scroll-container--horizontal",
      style: normalizeStyle(__spreadProps(__spreadValues(__spreadValues({}, $options.root.style["chart-scroll-container"]), $options.root.style["chart-scroll-container--horizontal"]), {
        marginLeft: $options.getMarginLeft
      })),
      onScroll: _cache[10] || (_cache[10] = (...args) => $options.onHorizontalScroll && $options.onHorizontalScroll(...args)),
      ref: "chartScrollContainerHorizontal"
    }, [
      createBaseVNode("div", {
        class: "gantt-elastic__chart-scroll--horizontal",
        style: normalizeStyle({ height: "1px", width: $options.root.state.options.width + "px" })
      }, null, 4)
    ], 36)
  ], 4);
}
var MainView = _export_sfc(_sfc_main$2, [["render", _sfc_render$2]]);
function getStyle(fontSize = "12px", fontFamily = "Arial, sans-serif") {
  return {
    fontSize,
    fontFamily,
    "main-view": {
      background: "#FFFFFF"
    },
    "main-container-wrapper": {
      overflow: "hidden",
      "border-top": "1px solid #eee",
      "border-bottom": "1px solid #eee"
    },
    "main-container": {
      float: "left",
      "max-width": "100%"
    },
    "main-view-container": {},
    container: {
      display: "flex",
      "max-width": "100%",
      height: "100%"
    },
    "calendar-wrapper": {
      "user-select": "none"
    },
    calendar: {
      width: "100%",
      background: "#f3f5f7",
      display: "block"
    },
    "calendar-row": {
      display: "flex",
      "justify-content": "space-evenly"
    },
    "calendar-row--month": {},
    "calendar-row--day": {},
    "calendar-row--hour": {
      "border-bottom": "1px solid #eee"
    },
    "calendar-row-rect": {
      background: "transparent",
      display: "flex"
    },
    "calendar-row-rect--month": {},
    "calendar-row-rect--day": {},
    "calendar-row-rect--hour": {},
    "calendar-row-rect-child": {
      display: "block",
      "border-right-width": "1px",
      "border-right-color": "#dadada",
      "border-right-style": "solid",
      position: "relative"
    },
    "calendar-row-rect-child--month": {},
    "calendar-row-rect-child--day": { "text-align": "center" },
    "calendar-row-rect-child--hour": { "text-align": "center" },
    "calendar-row-text": {
      "font-family": fontFamily,
      "font-size": fontSize,
      color: "#606060",
      display: "inline-block",
      position: "relative"
    },
    "calendar-row-text--month": {},
    "calendar-row-text--day": {},
    "calendar-row-text--hour": {},
    "task-list-wrapper": {},
    "task-list": { background: "transparent", "border-color": "#eee" },
    "task-list-header": {
      display: "flex",
      "user-select": "none",
      "vertical-align": "middle",
      "border-bottom": "1px solid #eee",
      "border-left": "1px solid #eee"
    },
    "task-list-header-column": {
      "border-left": "1px solid #00000050",
      "box-sizing": "border-box",
      display: "flex",
      background: "#f3f5f7",
      "border-color": "transparent"
    },
    "task-list-expander-wrapper": {
      display: "inline-flex",
      "flex-shrink": "0",
      "box-sizing": "border-box",
      margin: "0 0 0 10px"
    },
    "task-list-expander-content": {
      display: "inline-flex",
      cursor: "pointer",
      margin: "auto 0px",
      "box-sizing": "border-box",
      "user-select": "none"
    },
    "task-list-expander-line": {
      fill: "transparent",
      stroke: "#000000",
      "stroke-width": "1",
      "stroke-linecap": "round"
    },
    "task-list-expander-border": {
      fill: "#ffffffa0",
      stroke: "#000000A0"
    },
    "chart-expander-wrapper": {
      display: "block",
      "line-height": "1",
      "box-sizing": "border-box",
      margin: "0"
    },
    "chart-expander-content": {
      display: "inline-flex",
      cursor: "pointer",
      margin: "auto 0px",
      "box-sizing": "border-box",
      "user-select": "none"
    },
    "chart-expander-line": {
      fill: "transparent",
      stroke: "#000000",
      "stroke-width": "1",
      "stroke-linecap": "round"
    },
    "chart-expander-border": {
      fill: "#ffffffa0",
      stroke: "#000000A0"
    },
    "task-list-container": {},
    "task-list-header-label": {
      overflow: "hidden",
      "text-overflow": "ellipsis",
      "font-family": fontFamily,
      "font-size": fontSize,
      "box-sizing": "border-box",
      margin: "auto 6px",
      "flex-grow": "1",
      "vertical-align": "middle"
    },
    "task-list-header-resizer-wrapper": {
      background: "transparent",
      height: "100%",
      width: "6px",
      cursor: "col-resize",
      display: "inline-flex",
      "vertical-align": "center"
    },
    "task-list-header-resizer": { margin: "auto 0px" },
    "task-list-header-resizer-dot": {
      width: "3px",
      height: "3px",
      background: "#ddd",
      "border-radius": "100%",
      margin: "4px 0px"
    },
    "task-list-items": {
      overflow: "hidden"
    },
    "task-list-item": {
      "border-top": "1px solid #eee",
      "border-right": "1px solid #eee",
      "box-sizing": "border-box",
      display: "flex",
      background: "transparent"
    },
    "task-list-item-column": {
      display: "inline-flex",
      "flex-shrink": "0",
      "border-left": "1px solid #00000050",
      "box-sizing": "border-box",
      "border-color": "#eee"
    },
    "task-list-item-value-wrapper": {
      overflow: "hidden",
      display: "flex",
      width: "100%"
    },
    "task-list-item-value-container": {
      margin: "auto 0px",
      overflow: "hidden"
    },
    "task-list-item-value": {
      display: "block",
      "flex-shrink": "100",
      "font-family": fontFamily,
      "font-size": fontSize,
      "margin-top": "auto",
      "margin-bottom": "auto",
      "margin-left": "6px",
      "margin-right": "6px",
      overflow: "hidden",
      "text-overflow": "ellipsis",
      "line-height": "1.5em",
      "word-break": "keep-all",
      "white-space": "nowrap",
      color: "#606060",
      background: "#FFFFFF"
    },
    "grid-lines": {},
    "grid-line-horizontal": {
      stroke: "#00000010",
      "stroke-width": 1
    },
    "grid-line-vertical": {
      stroke: "#00000010",
      "stroke-width": 1
    },
    "grid-line-time": {
      stroke: "#FF000080",
      "stroke-width": 1
    },
    chart: {
      "user-select": "none",
      overflow: "hidden"
    },
    "chart-calendar-container": {
      "user-select": "none",
      overflow: "hidden",
      "max-width": "100%",
      "border-right": "1px solid #eee"
    },
    "chart-graph-container": {
      "user-select": "none",
      overflow: "hidden",
      "max-width": "100%",
      "border-right": "1px solid #eee"
    },
    "chart-area": {},
    "chart-graph": {
      overflow: "hidden"
    },
    "chart-row-text-wrapper": {},
    "chart-row-text": {
      background: "#ffffffa0",
      "border-radius": "10px",
      "font-family": fontFamily,
      "font-size": fontSize,
      "font-weight": "normal",
      color: "#000000a0",
      height: "100%",
      display: "inline-block"
    },
    "chart-row-text-content": {
      padding: "0px 6px"
    },
    "chart-row-text-content--text": {},
    "chart-row-text-content--html": {},
    "chart-row-wrapper": {},
    "chart-row-bar-wrapper": {},
    "chart-row-bar": {},
    "chart-row-bar-polygon": {
      stroke: "#E74C3C",
      "stroke-width": 1,
      fill: "#F75C4C"
    },
    "chart-row-project-wrapper": {},
    "chart-row-project": {},
    "chart-row-project-polygon": {},
    "chart-row-milestone-wrapper": {},
    "chart-row-milestone": {},
    "chart-row-milestone-polygon": {},
    "chart-row-task-wrapper": {},
    "chart-row-task": {},
    "chart-row-task-polygon": {},
    "chart-row-progress-bar-wrapper": {},
    "chart-row-progress-bar": {},
    "chart-row-progress-bar-line": {
      stroke: "#ffffff25",
      "stroke-width": 20
    },
    "chart-row-progress-bar-solid": {
      fill: "#0EAC51",
      height: "20%"
    },
    "chart-row-progress-bar-pattern": {
      fill: "url(#diagonalHatch)",
      transform: "translateY(0.1) scaleY(0.8)"
    },
    "chart-row-progress-bar-outline": {
      stroke: "#E74C3C",
      "stroke-width": 1
    },
    "chart-dependency-lines-wrapper": {},
    "chart-dependency-lines-path": {
      fill: "transparent",
      stroke: "#FFa00090",
      "stroke-width": 2
    },
    "chart-scroll-container": {},
    "chart-scroll-container--horizontal": {
      overflow: "auto",
      "max-width": "100%"
    },
    "chart-scroll-container--vertical": {
      "overflow-y": "auto",
      "overflow-x": "hidden",
      "max-height": "100%",
      float: "right"
    },
    "chart-days-highlight-rect": {
      fill: "#f3f5f780"
    },
    "slot-header-beforeOptions": {
      display: "inline-block"
    }
  };
}
var MapShim = function() {
  if (typeof Map !== "undefined") {
    return Map;
  }
  function getIndex(arr, key) {
    var result = -1;
    arr.some(function(entry, index2) {
      if (entry[0] === key) {
        result = index2;
        return true;
      }
      return false;
    });
    return result;
  }
  return function() {
    function class_1() {
      this.__entries__ = [];
    }
    Object.defineProperty(class_1.prototype, "size", {
      get: function() {
        return this.__entries__.length;
      },
      enumerable: true,
      configurable: true
    });
    class_1.prototype.get = function(key) {
      var index2 = getIndex(this.__entries__, key);
      var entry = this.__entries__[index2];
      return entry && entry[1];
    };
    class_1.prototype.set = function(key, value) {
      var index2 = getIndex(this.__entries__, key);
      if (~index2) {
        this.__entries__[index2][1] = value;
      } else {
        this.__entries__.push([key, value]);
      }
    };
    class_1.prototype.delete = function(key) {
      var entries = this.__entries__;
      var index2 = getIndex(entries, key);
      if (~index2) {
        entries.splice(index2, 1);
      }
    };
    class_1.prototype.has = function(key) {
      return !!~getIndex(this.__entries__, key);
    };
    class_1.prototype.clear = function() {
      this.__entries__.splice(0);
    };
    class_1.prototype.forEach = function(callback, ctx2) {
      if (ctx2 === void 0) {
        ctx2 = null;
      }
      for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
        var entry = _a[_i];
        callback.call(ctx2, entry[1], entry[0]);
      }
    };
    return class_1;
  }();
}();
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
var global$1 = function() {
  if (typeof global !== "undefined" && global.Math === Math) {
    return global;
  }
  if (typeof self !== "undefined" && self.Math === Math) {
    return self;
  }
  if (typeof window !== "undefined" && window.Math === Math) {
    return window;
  }
  return Function("return this")();
}();
var requestAnimationFrame$1 = function() {
  if (typeof requestAnimationFrame === "function") {
    return requestAnimationFrame.bind(global$1);
  }
  return function(callback) {
    return setTimeout(function() {
      return callback(Date.now());
    }, 1e3 / 60);
  };
}();
var trailingTimeout = 2;
function throttle(callback, delay) {
  var leadingCall = false, trailingCall = false, lastCallTime = 0;
  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }
    if (trailingCall) {
      proxy();
    }
  }
  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  function proxy() {
    var timeStamp = Date.now();
    if (leadingCall) {
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      }
      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }
    lastCallTime = timeStamp;
  }
  return proxy;
}
var REFRESH_DELAY = 20;
var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
var mutationObserverSupported = typeof MutationObserver !== "undefined";
var ResizeObserverController = function() {
  function ResizeObserverController2() {
    this.connected_ = false;
    this.mutationEventsAdded_ = false;
    this.mutationsObserver_ = null;
    this.observers_ = [];
    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
  }
  ResizeObserverController2.prototype.addObserver = function(observer) {
    if (!~this.observers_.indexOf(observer)) {
      this.observers_.push(observer);
    }
    if (!this.connected_) {
      this.connect_();
    }
  };
  ResizeObserverController2.prototype.removeObserver = function(observer) {
    var observers2 = this.observers_;
    var index2 = observers2.indexOf(observer);
    if (~index2) {
      observers2.splice(index2, 1);
    }
    if (!observers2.length && this.connected_) {
      this.disconnect_();
    }
  };
  ResizeObserverController2.prototype.refresh = function() {
    var changesDetected = this.updateObservers_();
    if (changesDetected) {
      this.refresh();
    }
  };
  ResizeObserverController2.prototype.updateObservers_ = function() {
    var activeObservers = this.observers_.filter(function(observer) {
      return observer.gatherActive(), observer.hasActive();
    });
    activeObservers.forEach(function(observer) {
      return observer.broadcastActive();
    });
    return activeObservers.length > 0;
  };
  ResizeObserverController2.prototype.connect_ = function() {
    if (!isBrowser || this.connected_) {
      return;
    }
    document.addEventListener("transitionend", this.onTransitionEnd_);
    window.addEventListener("resize", this.refresh);
    if (mutationObserverSupported) {
      this.mutationsObserver_ = new MutationObserver(this.refresh);
      this.mutationsObserver_.observe(document, {
        attributes: true,
        childList: true,
        characterData: true,
        subtree: true
      });
    } else {
      document.addEventListener("DOMSubtreeModified", this.refresh);
      this.mutationEventsAdded_ = true;
    }
    this.connected_ = true;
  };
  ResizeObserverController2.prototype.disconnect_ = function() {
    if (!isBrowser || !this.connected_) {
      return;
    }
    document.removeEventListener("transitionend", this.onTransitionEnd_);
    window.removeEventListener("resize", this.refresh);
    if (this.mutationsObserver_) {
      this.mutationsObserver_.disconnect();
    }
    if (this.mutationEventsAdded_) {
      document.removeEventListener("DOMSubtreeModified", this.refresh);
    }
    this.mutationsObserver_ = null;
    this.mutationEventsAdded_ = false;
    this.connected_ = false;
  };
  ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {
    var _b = _a.propertyName, propertyName = _b === void 0 ? "" : _b;
    var isReflowProperty = transitionKeys.some(function(key) {
      return !!~propertyName.indexOf(key);
    });
    if (isReflowProperty) {
      this.refresh();
    }
  };
  ResizeObserverController2.getInstance = function() {
    if (!this.instance_) {
      this.instance_ = new ResizeObserverController2();
    }
    return this.instance_;
  };
  ResizeObserverController2.instance_ = null;
  return ResizeObserverController2;
}();
var defineConfigurable = function(target, props) {
  for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
    var key = _a[_i];
    Object.defineProperty(target, key, {
      value: props[key],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  return target;
};
var getWindowOf = function(target) {
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
  return ownerGlobal || global$1;
};
var emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(value) {
  return parseFloat(value) || 0;
}
function getBordersSize(styles) {
  var positions = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }
  return positions.reduce(function(size, position) {
    var value = styles["border-" + position + "-width"];
    return size + toFloat(value);
  }, 0);
}
function getPaddings(styles) {
  var positions = ["top", "right", "bottom", "left"];
  var paddings = {};
  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position = positions_1[_i];
    var value = styles["padding-" + position];
    paddings[position] = toFloat(value);
  }
  return paddings;
}
function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
function getHTMLElementContentRect(target) {
  var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }
  var styles = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom;
  var width = toFloat(styles.width), height = toFloat(styles.height);
  if (styles.boxSizing === "border-box") {
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles, "left", "right") + horizPad;
    }
    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles, "top", "bottom") + vertPad;
    }
  }
  if (!isDocumentElement(target)) {
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight;
    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }
    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }
  return createRectInit(paddings.left, paddings.top, width, height);
}
var isSVGGraphicsElement = function() {
  if (typeof SVGGraphicsElement !== "undefined") {
    return function(target) {
      return target instanceof getWindowOf(target).SVGGraphicsElement;
    };
  }
  return function(target) {
    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
  };
}();
function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
function getContentRect(target) {
  if (!isBrowser) {
    return emptyRect;
  }
  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }
  return getHTMLElementContentRect(target);
}
function createReadOnlyRect(_a) {
  var x2 = _a.x, y2 = _a.y, width = _a.width, height = _a.height;
  var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype);
  defineConfigurable(rect, {
    x: x2,
    y: y2,
    width,
    height,
    top: y2,
    right: x2 + width,
    bottom: height + y2,
    left: x2
  });
  return rect;
}
function createRectInit(x2, y2, width, height) {
  return { x: x2, y: y2, width, height };
}
var ResizeObservation = function() {
  function ResizeObservation2(target) {
    this.broadcastWidth = 0;
    this.broadcastHeight = 0;
    this.contentRect_ = createRectInit(0, 0, 0, 0);
    this.target = target;
  }
  ResizeObservation2.prototype.isActive = function() {
    var rect = getContentRect(this.target);
    this.contentRect_ = rect;
    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
  };
  ResizeObservation2.prototype.broadcastRect = function() {
    var rect = this.contentRect_;
    this.broadcastWidth = rect.width;
    this.broadcastHeight = rect.height;
    return rect;
  };
  return ResizeObservation2;
}();
var ResizeObserverEntry = /* @__PURE__ */ function() {
  function ResizeObserverEntry2(target, rectInit) {
    var contentRect = createReadOnlyRect(rectInit);
    defineConfigurable(this, { target, contentRect });
  }
  return ResizeObserverEntry2;
}();
var ResizeObserverSPI = function() {
  function ResizeObserverSPI2(callback, controller, callbackCtx) {
    this.activeObservations_ = [];
    this.observations_ = new MapShim();
    if (typeof callback !== "function") {
      throw new TypeError("The callback provided as parameter 1 is not a function.");
    }
    this.callback_ = callback;
    this.controller_ = controller;
    this.callbackCtx_ = callbackCtx;
  }
  ResizeObserverSPI2.prototype.observe = function(target) {
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    if (typeof Element === "undefined" || !(Element instanceof Object)) {
      return;
    }
    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }
    var observations = this.observations_;
    if (observations.has(target)) {
      return;
    }
    observations.set(target, new ResizeObservation(target));
    this.controller_.addObserver(this);
    this.controller_.refresh();
  };
  ResizeObserverSPI2.prototype.unobserve = function(target) {
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    if (typeof Element === "undefined" || !(Element instanceof Object)) {
      return;
    }
    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }
    var observations = this.observations_;
    if (!observations.has(target)) {
      return;
    }
    observations.delete(target);
    if (!observations.size) {
      this.controller_.removeObserver(this);
    }
  };
  ResizeObserverSPI2.prototype.disconnect = function() {
    this.clearActive();
    this.observations_.clear();
    this.controller_.removeObserver(this);
  };
  ResizeObserverSPI2.prototype.gatherActive = function() {
    var _this = this;
    this.clearActive();
    this.observations_.forEach(function(observation) {
      if (observation.isActive()) {
        _this.activeObservations_.push(observation);
      }
    });
  };
  ResizeObserverSPI2.prototype.broadcastActive = function() {
    if (!this.hasActive()) {
      return;
    }
    var ctx2 = this.callbackCtx_;
    var entries = this.activeObservations_.map(function(observation) {
      return new ResizeObserverEntry(observation.target, observation.broadcastRect());
    });
    this.callback_.call(ctx2, entries, ctx2);
    this.clearActive();
  };
  ResizeObserverSPI2.prototype.clearActive = function() {
    this.activeObservations_.splice(0);
  };
  ResizeObserverSPI2.prototype.hasActive = function() {
    return this.activeObservations_.length > 0;
  };
  return ResizeObserverSPI2;
}();
var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
var ResizeObserver = /* @__PURE__ */ function() {
  function ResizeObserver2(callback) {
    if (!(this instanceof ResizeObserver2)) {
      throw new TypeError("Cannot call a class as a function.");
    }
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    var controller = ResizeObserverController.getInstance();
    var observer = new ResizeObserverSPI(callback, controller, this);
    observers.set(this, observer);
  }
  return ResizeObserver2;
}();
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(method) {
  ResizeObserver.prototype[method] = function() {
    var _a;
    return (_a = observers.get(this))[method].apply(_a, arguments);
  };
});
var index = function() {
  if (typeof global$1.ResizeObserver !== "undefined") {
    return global$1.ResizeObserver;
  }
  return ResizeObserver;
}();
function mitt(n) {
  return { all: n = n || /* @__PURE__ */ new Map(), on: function(t, e) {
    var i = n.get(t);
    i ? i.push(e) : n.set(t, [e]);
  }, off: function(t, e) {
    var i = n.get(t);
    i && (e ? i.splice(i.indexOf(e) >>> 0, 1) : n.set(t, []));
  }, emit: function(t, e) {
    var i = n.get(t);
    i && i.slice().map(function(n2) {
      n2(e);
    }), (i = n.get("*")) && i.slice().map(function(n2) {
      n2(t, e);
    });
  } };
}
var ctx = document.createElement("canvas").getContext("2d");
function getOptions(userOptions) {
  if (typeof userOptions.locale !== "undefined" && typeof userOptions.locale.name !== "undefined") {
    userOptions.locale.name;
  }
  return {
    slots: {
      header: {}
    },
    taskMapping: {
      id: "id",
      start: "start",
      label: "label",
      duration: "duration",
      progress: "progress",
      type: "type",
      style: "style",
      collapsed: "collapsed"
    },
    width: 0,
    height: 0,
    clientWidth: 0,
    outerHeight: 0,
    rowsHeight: 0,
    allVisibleTasksHeight: 0,
    scroll: {
      scrolling: false,
      dragXMoveMultiplier: 3,
      dragYMoveMultiplier: 2,
      top: 0,
      taskList: {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      },
      chart: {
        left: 0,
        right: 0,
        percent: 0,
        timePercent: 0,
        top: 0,
        bottom: 0,
        time: 0,
        timeCenter: 0,
        dateTime: {
          left: "",
          right: ""
        }
      }
    },
    scope: {
      before: 1,
      after: 1
    },
    times: {
      timeScale: 60 * 1e3,
      timeZoom: 17,
      timePerPixel: 0,
      firstTime: null,
      lastTime: null,
      firstTaskTime: 0,
      lastTaskTime: 0,
      totalViewDurationMs: 0,
      totalViewDurationPx: 0,
      stepDuration: "day",
      steps: []
    },
    row: {
      height: 24
    },
    maxRows: 20,
    maxHeight: 0,
    chart: {
      grid: {
        horizontal: {
          gap: 6
        }
      },
      progress: {
        width: 20,
        height: 6,
        pattern: true,
        bar: false
      },
      text: {
        offset: 4,
        xPadding: 10,
        display: true
      },
      expander: {
        type: "chart",
        display: false,
        displayIfTaskListHidden: true,
        offset: 4,
        size: 18
      }
    },
    taskList: {
      display: true,
      resizeAfterThreshold: true,
      widthThreshold: 75,
      columns: [
        {
          id: 0,
          label: "ID",
          value: "id",
          width: 40
        }
      ],
      percent: 100,
      width: 0,
      finalWidth: 0,
      widthFromPercentage: 0,
      minWidth: 18,
      expander: {
        type: "task-list",
        size: 16,
        columnWidth: 24,
        padding: 16,
        margin: 10,
        straight: false
      }
    },
    calendar: {
      workingDays: [1, 2, 3, 4, 5],
      gap: 6,
      height: 0,
      strokeWidth: 1,
      hour: {
        height: 20,
        display: true,
        widths: [],
        maxWidths: { short: 0, medium: 0, long: 0 },
        formatted: {
          long: [],
          medium: [],
          short: []
        },
        format: {
          long(date) {
            return date.format("HH:mm");
          },
          medium(date) {
            return date.format("HH:mm");
          },
          short(date) {
            return date.format("HH");
          }
        }
      },
      day: {
        height: 20,
        display: true,
        widths: [],
        maxWidths: { short: 0, medium: 0, long: 0 },
        format: {
          long(date) {
            return date.format("DD dddd");
          },
          medium(date) {
            return date.format("DD ddd");
          },
          short(date) {
            return date.format("DD");
          }
        }
      },
      month: {
        height: 20,
        display: true,
        widths: [],
        maxWidths: { short: 0, medium: 0, long: 0 },
        format: {
          short(date) {
            return date.format("MM");
          },
          medium(date) {
            return date.format("MMM 'YY");
          },
          long(date) {
            return date.format("MMMM YYYY");
          }
        }
      }
    },
    locale: {
      name: "en",
      weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
      weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
      weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
      months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
      monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
      weekStart: 1,
      relativeTime: {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      },
      formats: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd, D MMMM YYYY HH:mm"
      },
      ordinal: (n) => {
        const s2 = ["th", "st", "nd", "rd"];
        const v2 = n % 100;
        return `[${n}${s2[(v2 - 20) % 10] || s2[v2] || s2[0]}]`;
      }
    }
  };
}
function prepareStyle(userStyle) {
  let fontSize = "12px";
  let fontFamily = window.getComputedStyle(document.body).getPropertyValue("font-family").toString();
  if (typeof userStyle !== "undefined") {
    if (typeof userStyle.fontSize !== "undefined") {
      fontSize = userStyle.fontSize;
    }
    if (typeof userStyle.fontFamily !== "undefined") {
      fontFamily = userStyle.fontFamily;
    }
  }
  return getStyle(fontSize, fontFamily);
}
function isObject(item) {
  return item && typeof item === "object" && !Array.isArray(item) && !(item instanceof HTMLElement) && !(item instanceof CanvasRenderingContext2D) && typeof item !== "function";
}
function mergeDeep(target, ...sources) {
  if (!sources.length) {
    return target;
  }
  const source = sources.shift();
  if (isObject(target) && isObject(source)) {
    for (const key in source) {
      if (isObject(source[key])) {
        if (typeof target[key] === "undefined") {
          target[key] = {};
        }
        target[key] = mergeDeep(target[key], source[key]);
      } else if (Array.isArray(source[key])) {
        target[key] = [];
        for (let item of source[key]) {
          if (isObject(item)) {
            target[key].push(mergeDeep({}, item));
            continue;
          }
          target[key].push(item);
        }
      } else {
        target[key] = source[key];
      }
    }
  }
  return mergeDeep(target, ...sources);
}
function mergeDeepReactive(component, target, ...sources) {
  if (!sources.length) {
    return target;
  }
  const source = sources.shift();
  if (isObject(target) && isObject(source)) {
    for (const key in source) {
      if (isObject(source[key])) {
        if (typeof target[key] === "undefined") {
          component.$set(target, key, {});
        }
        mergeDeepReactive(component, target[key], source[key]);
      } else if (Array.isArray(source[key])) {
        component.$set(target, key, source[key]);
      } else if (typeof source[key] === "function") {
        if (source[key].toString().indexOf("[native code]") === -1) {
          target[key] = source[key];
        }
      } else {
        component.$set(target, key, source[key]);
      }
    }
  }
  return mergeDeepReactive(component, target, ...sources);
}
function notEqualDeep(left, right, cache = [], path = "") {
  if (typeof right !== typeof left) {
    console.log("notEqualDeep 1");
    return { left, right, what: path + ".typeof" };
  } else if (Array.isArray(left) && !Array.isArray(right)) {
    console.log("notEqualDeep 2");
    return { left, right, what: path + ".isArray" };
  } else if (Array.isArray(right) && !Array.isArray(left)) {
    console.log("notEqualDeep 3");
    return { left, right, what: path + ".isArray" };
  } else if (Array.isArray(left) && Array.isArray(right)) {
    if (left.length !== right.length) {
      console.log("notEqualDeep 4");
      return { left, right, what: path + ".length" };
    }
    let what;
    for (let index2 = 0, len = left.length; index2 < len; index2++) {
      if (what = notEqualDeep(left[index2], right[index2], cache, path + "." + index2)) {
        console.log("notEqualDeep 5");
        return what;
      }
    }
  } else if (isObject(left) && !isObject(right)) {
    console.log("notEqualDeep 6");
    return { left, right, what: path + ".isObject" };
  } else if (isObject(right) && !isObject(left)) {
    console.log("notEqualDeep 7");
    return { left, right, what: path + ".isObject" };
  } else if (isObject(left) && isObject(right)) {
    for (let key in left) {
      if (!left.hasOwnProperty(key) || !left.propertyIsEnumerable(key)) {
        continue;
      }
      if (!right.hasOwnProperty(key)) {
        console.log("notEqualDeep 8");
        return { left, right, what: path + "." + key };
      }
      let what;
      if (what = notEqualDeep(left[key], right[key], cache, path + "." + key)) {
        console.log("notEqualDeep 9");
        return what;
      }
    }
  } else if (left !== right) {
    console.log("notEqualDeep 10");
    return { left, right, what: path + ". !==" };
  }
  console.log("notEqualDeep 11");
  return false;
}
var GanttElastic = {
  name: "GanttElastic",
  components: {
    MainView
  },
  props: ["tasks", "options", "dynamicStyle"],
  provide() {
    const provider = {};
    const self2 = this;
    Object.defineProperty(provider, "root", {
      enumerable: true,
      get: () => self2
    });
    return provider;
  },
  data() {
    return {
      state: {
        tasks: [],
        options: {
          scrollBarHeight: 0,
          allVisibleTasksHeight: 0,
          outerHeight: 0,
          scroll: {
            left: 0,
            top: 0
          }
        },
        dynamicStyle: {},
        refs: {},
        tasksById: {},
        taskTree: {},
        ctx,
        emitTasksChanges: true,
        emitOptionsChanges: true,
        resizeObserver: null,
        unwatchTasks: null,
        unwatchOptions: null,
        unwatchStyle: null,
        unwatchOutputTasks: null,
        unwatchOutputOptions: null,
        unwatchOutputStyle: null
      }
    };
  },
  methods: {
    mergeDeep,
    mergeDeepReactive,
    getScrollBarHeight() {
      const outer = document.createElement("div");
      outer.style.visibility = "hidden";
      outer.style.height = "100px";
      outer.style.msOverflowStyle = "scrollbar";
      document.body.appendChild(outer);
      var noScroll = outer.offsetHeight;
      outer.style.overflow = "scroll";
      var inner = document.createElement("div");
      inner.style.height = "100%";
      outer.appendChild(inner);
      var withScroll = inner.offsetHeight;
      outer.parentNode.removeChild(outer);
      const height = noScroll - withScroll;
      this.style["chart-scroll-container--vertical"]["margin-left"] = `-${height}px`;
      return this.state.options.scrollBarHeight = height;
    },
    fillTasks(tasks) {
      for (let task of tasks) {
        if (typeof task.x === "undefined") {
          task.x = 0;
        }
        if (typeof task.y === "undefined") {
          task.y = 0;
        }
        if (typeof task.width === "undefined") {
          task.width = 0;
        }
        if (typeof task.height === "undefined") {
          task.height = 0;
        }
        if (typeof task.mouseOver === "undefined") {
          task.mouseOver = false;
        }
        if (typeof task.collapsed === "undefined") {
          task.collapsed = false;
        }
        if (typeof task.dependentOn === "undefined") {
          task.dependentOn = [];
        }
        if (typeof task.parentId === "undefined") {
          task.parentId = null;
        }
        if (typeof task.style === "undefined") {
          task.style = {};
        }
        if (typeof task.children === "undefined") {
          task.children = [];
        }
        if (typeof task.allChildren === "undefined") {
          task.allChildren = [];
        }
        if (typeof task.parents === "undefined") {
          task.parents = [];
        }
        if (typeof task.parent === "undefined") {
          task.parent = null;
        }
        if (typeof task.startTime === "undefined") {
          task.startTime = dayjs(task.start).valueOf();
        }
        if (typeof task.endTime === "undefined" && task.hasOwnProperty("end")) {
          task.endTime = dayjs(task.end).valueOf();
        } else if (typeof task.endTime === "undefined" && task.hasOwnProperty("duration")) {
          task.endTime = task.startTime + task.duration;
        }
        if (typeof task.duration === "undefined" && task.hasOwnProperty("endTime")) {
          task.duration = task.endTime - task.startTime;
        }
      }
      return tasks;
    },
    mapTasks(tasks, options) {
      for (let [index2, task] of tasks.entries()) {
        tasks[index2] = __spreadProps(__spreadValues({}, task), {
          id: task[options.taskMapping.id],
          start: task[options.taskMapping.start],
          label: task[options.taskMapping.label],
          duration: task[options.taskMapping.duration],
          progress: task[options.taskMapping.progress],
          type: task[options.taskMapping.type],
          style: task[options.taskMapping.style],
          collapsed: task[options.taskMapping.collapsed]
        });
      }
      return tasks;
    },
    initialize(itsUpdate = "") {
      let options = mergeDeep({}, this.state.options, getOptions(this.options), this.options);
      let tasks = this.mapTasks(this.tasks, options);
      if (Object.keys(this.state.dynamicStyle).length === 0) {
        this.initializeStyle();
      }
      dayjs.locale(options.locale, null, true);
      dayjs.locale(options.locale.name);
      if (typeof options.taskList === "undefined") {
        options.taskList = {};
      }
      options.taskList.columns = options.taskList.columns.map((column, index2) => {
        column.thresholdPercent = 100;
        column.widthFromPercentage = 0;
        column.finalWidth = 0;
        if (typeof column.height === "undefined") {
          column.height = 0;
        }
        if (typeof column.style === "undefined") {
          column.style = {};
        }
        column._id = `${index2}-${column.label}`;
        return column;
      });
      this.state.options = options;
      tasks.forEach((task) => {
        if (task.type == "multiple" && task.subTask.length > 0) {
          if (typeof task.start == "undefined") {
            task.subTask.sort((a, b2) => a.start - b2.start);
            task.start = task.subTask[0].start;
          }
          if (typeof task.duration == "undefined") {
            task.subTask.sort((a, b2) => a.start - b2.start);
            task.duration = task.subTask[task.subTask.length - 1].start - task.subTask[0].start;
          }
        }
      });
      tasks = this.fillTasks(tasks);
      tasks.forEach((task) => {
        if (task.type == "multiple" && task.subTask.length > 0) {
          task.subTask = this.fillTasks(task.subTask);
        }
      });
      this.state.tasksById = this.resetTaskTree(tasks);
      this.state.taskTree = this.makeTaskTree(this.state.rootTask, tasks);
      this.state.tasks = this.state.taskTree.allChildren.map((childId) => this.getTask(childId));
      this.calculateTaskListColumnsDimensions();
      this.state.options.scrollBarHeight = this.getScrollBarHeight();
      this.state.options.outerHeight = this.state.options.height + this.state.options.scrollBarHeight;
      this.globalOnResize();
    },
    initializeStyle() {
      this.state.dynamicStyle = mergeDeep({}, prepareStyle(this.dynamicStyle), this.dynamicStyle);
    },
    getCalendarHeight() {
      return this.state.options.calendar.height + this.state.options.calendar.strokeWidth;
    },
    getMaximalLevel() {
      let maximalLevel = 0;
      this.state.tasks.forEach((task) => {
        if (task.parents.length > maximalLevel) {
          maximalLevel = task.parents.length;
        }
      });
      return maximalLevel - 1;
    },
    getMaximalExpanderWidth() {
      return this.getMaximalLevel() * this.state.options.taskList.expander.padding + this.state.options.taskList.expander.margin;
    },
    syncScrollTop() {
      if (this.state.refs.taskListItems && this.state.refs.chartGraph.scrollTop !== this.state.refs.taskListItems.scrollTop) {
        this.state.options.scroll.top = this.state.refs.taskListItems.scrollTop = this.state.refs.chartScrollContainerVertical.scrollTop = this.state.refs.chartGraph.scrollTop;
      }
    },
    calculateTaskListColumnsDimensions() {
      let final = 0;
      let percentage = 0;
      for (let column of this.state.options.taskList.columns) {
        if (column.expander) {
          column.widthFromPercentage = (this.getMaximalExpanderWidth() + column.width) / 100 * this.state.options.taskList.percent;
        } else {
          column.widthFromPercentage = column.width / 100 * this.state.options.taskList.percent;
        }
        percentage += column.widthFromPercentage;
        column.finalWidth = column.thresholdPercent * column.widthFromPercentage / 100;
        final += column.finalWidth;
        column.height = this.getTaskHeight() - this.style["grid-line-horizontal"]["stroke-width"];
      }
      this.state.options.taskList.widthFromPercentage = percentage;
      this.state.options.taskList.finalWidth = final;
    },
    resetTaskTree(tasks) {
      this.state["rootTask"] = {
        id: null,
        label: "root",
        children: [],
        allChildren: [],
        parents: [],
        parent: null,
        __root: true
      };
      const tasksById = {};
      for (let i = 0, len = tasks.length; i < len; i++) {
        let current = tasks[i];
        current.children = [];
        current.allChildren = [];
        current.parent = null;
        current.parents = [];
        tasksById[current.id] = current;
      }
      return tasksById;
    },
    makeTaskTree(task, tasks) {
      for (let i = 0, len = tasks.length; i < len; i++) {
        let current = tasks[i];
        if (current.parentId === task.id) {
          if (task.parents.length) {
            task.parents.forEach((parent) => current.parents.push(parent));
          }
          if (!task.propertyIsEnumerable("__root")) {
            current.parents.push(task.id);
            current.parent = task.id;
          } else {
            current.parents = [];
            current.parent = null;
          }
          current = this.makeTaskTree(current, tasks);
          task.allChildren.push(current.id);
          task.children.push(current.id);
          current.allChildren.forEach((childId) => task.allChildren.push(childId));
        }
      }
      return task;
    },
    getTask(taskId) {
      if (typeof this.state.tasksById[taskId] !== "undefined") {
        return this.state.tasksById[taskId];
      }
      return null;
    },
    getChildren(taskId) {
      return this.state.tasks.filter((task) => task.parent === taskId);
    },
    isTaskVisible(task) {
      if (typeof task === "number" || typeof task === "string") {
        task = this.getTask(task);
      }
      for (let i = 0, len = task.parents.length; i < len; i++) {
        if (this.getTask(task.parents[i]).collapsed) {
          return false;
        }
      }
      return true;
    },
    getSVG() {
      return this.state.options.mainView.outerHTML;
    },
    getImage(type = "image/png") {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement("canvas");
          canvas.width = this.state.options.mainView.clientWidth;
          canvas.height = this.state.options.rowsHeight;
          canvas.getContext("2d").drawImage(img, 0, 0);
          resolve(canvas.toDataURL(type));
        };
        img.src = "data:image/svg+xml," + encodeURIComponent(this.getSVG());
      });
    },
    getHeight(visibleTasks, outer = false) {
      let height = visibleTasks.length * (this.state.options.row.height + this.state.options.chart.grid.horizontal.gap * 2) + this.state.options.calendar.height + this.state.options.calendar.strokeWidth + this.state.options.calendar.gap;
      if (outer) {
        height += this.state.options.scrollBarHeight;
      }
      return height;
    },
    getTaskHeight(withStroke = false) {
      if (withStroke) {
        return this.state.options.row.height + this.state.options.chart.grid.horizontal.gap * 2 + this.style["grid-line-horizontal"]["stroke-width"];
      }
      return this.state.options.row.height + this.state.options.chart.grid.horizontal.gap * 2;
    },
    getTasksHeight(visibleTasks) {
      return visibleTasks.length * this.getTaskHeight();
    },
    timeToPixelOffsetX(ms) {
      let x2 = ms - this.state.options.times.firstTime;
      if (x2) {
        x2 = x2 / this.state.options.times.timePerPixel;
      }
      return x2;
    },
    pixelOffsetXToTime(pixelOffsetX) {
      let offset = pixelOffsetX + this.style["grid-line-vertical"]["stroke-width"] / 2;
      return offset * this.state.options.times.timePerPixel + this.state.options.times.firstTime;
    },
    isInsideViewPort(x2, width, buffer = 5e3) {
      return x2 + width + buffer >= this.state.options.scroll.chart.left && x2 - buffer <= this.state.options.scroll.chart.right || x2 - buffer <= this.state.options.scroll.chart.left && x2 + width + buffer >= this.state.options.scroll.chart.right;
    },
    onScrollChart(ev) {
      this._onScrollChart(this.state.refs.chartScrollContainerHorizontal.scrollLeft, this.state.refs.chartScrollContainerVertical.scrollTop);
    },
    _onScrollChart(left, top) {
      if (this.state.options.scroll.chart.left === left && this.state.options.scroll.chart.top === top) {
        return;
      }
      const chartContainerWidth = this.state.refs.chartContainer.clientWidth;
      this.state.options.scroll.chart.left = left;
      this.state.options.scroll.chart.right = left + chartContainerWidth;
      this.state.options.scroll.chart.percent = left / this.state.options.times.totalViewDurationPx * 100;
      this.state.options.scroll.chart.top = top;
      this.state.options.scroll.chart.time = this.pixelOffsetXToTime(left);
      this.state.options.scroll.chart.timeCenter = this.pixelOffsetXToTime(left + chartContainerWidth / 2);
      this.state.options.scroll.chart.dateTime.left = dayjs(this.state.options.scroll.chart.time).valueOf();
      this.state.options.scroll.chart.dateTime.right = dayjs(this.pixelOffsetXToTime(left + this.state.refs.chart.clientWidth)).valueOf();
      this.scrollTo(left, top);
    },
    scrollToTime(time) {
      let pos = this.timeToPixelOffsetX(time);
      const chartContainerWidth = this.state.refs.chartContainer.clientWidth;
      pos = pos - chartContainerWidth / 2;
      if (pos > this.state.options.width) {
        pos = this.state.options.width - chartContainerWidth;
      }
      this.scrollTo(pos);
    },
    scrollTo(left = null, top = null) {
      if (left !== null) {
        this.state.refs.chartCalendarContainer.scrollLeft = left;
        this.state.refs.chartGraphContainer.scrollLeft = left;
        this.state.refs.chartScrollContainerHorizontal.scrollLeft = left;
        this.state.options.scroll.left = left;
      }
      if (top !== null) {
        this.state.refs.chartScrollContainerVertical.scrollTop = top;
        this.state.refs.chartGraph.scrollTop = top;
        this.state.refs.taskListItems.scrollTop = top;
        this.state.options.scroll.top = top;
        this.syncScrollTop();
      }
    },
    fixScrollPos() {
      this.scrollToTime(this.state.options.scroll.chart.timeCenter);
    },
    onWheelChart(ev) {
      if (!ev.shiftKey && ev.deltaX === 0) {
        let top = this.state.options.scroll.top + ev.deltaY;
        const chartClientHeight = this.state.options.rowsHeight;
        const scrollHeight = this.state.refs.chartGraph.scrollHeight - chartClientHeight;
        if (top < 0) {
          top = 0;
        } else if (top > scrollHeight) {
          top = scrollHeight;
        }
        this.scrollTo(null, top);
      } else if (ev.shiftKey && ev.deltaX === 0) {
        let left = this.state.options.scroll.left + ev.deltaY;
        const chartClientWidth = this.state.refs.chartScrollContainerHorizontal.clientWidth;
        const scrollWidth = this.state.refs.chartScrollContainerHorizontal.scrollWidth - chartClientWidth;
        if (left < 0) {
          left = 0;
        } else if (left > scrollWidth) {
          left = scrollWidth;
        }
        this.scrollTo(left);
      } else {
        let left = this.state.options.scroll.left + ev.deltaX;
        const chartClientWidth = this.state.refs.chartScrollContainerHorizontal.clientWidth;
        const scrollWidth = this.state.refs.chartScrollContainerHorizontal.scrollWidth - chartClientWidth;
        if (left < 0) {
          left = 0;
        } else if (left > scrollWidth) {
          left = scrollWidth;
        }
        this.scrollTo(left);
      }
    },
    onTimeZoomChange(timeZoom) {
      this.state.options.times.timeZoom = timeZoom;
      this.recalculateTimes();
      this.calculateSteps();
      this.fixScrollPos();
    },
    onRowHeightChange(height) {
      this.state.options.row.height = height;
      this.calculateTaskListColumnsDimensions();
      this.syncScrollTop();
    },
    onScopeChange(value) {
      this.state.options.scope.before = value;
      this.state.options.scope.after = value;
      this.initTimes();
      this.calculateSteps();
      this.computeCalendarWidths();
      this.fixScrollPos();
    },
    onTaskListWidthChange(value) {
      this.state.options.taskList.percent = value;
      this.calculateTaskListColumnsDimensions();
      this.fixScrollPos();
    },
    onTaskListColumnWidthChange() {
      this.calculateTaskListColumnsDimensions();
      this.fixScrollPos();
    },
    initializeEvents() {
      this.$root.emitter.on("chart-scroll-horizontal", this.onScrollChart);
      this.$root.emitter.on("chart-scroll-vertical", this.onScrollChart);
      this.$root.emitter.on("chart-wheel", this.onWheelChart);
      this.$root.emitter.on("times-timeZoom-change", this.onTimeZoomChange);
      this.$root.emitter.on("row-height-change", this.onRowHeightChange);
      this.$root.emitter.on("scope-change", this.onScopeChange);
      this.$root.emitter.on("taskList-width-change", this.onTaskListWidthChange);
      this.$root.emitter.on("taskList-column-width-change", this.onTaskListColumnWidthChange);
    },
    recalculateTimes() {
      let max = this.state.options.times.timeScale * 60;
      let min = this.state.options.times.timeScale;
      let steps = max / min;
      let percent = this.state.options.times.timeZoom / 100;
      this.state.options.times.timePerPixel = this.state.options.times.timeScale * steps * percent + Math.pow(2, this.state.options.times.timeZoom);
      this.state.options.times.totalViewDurationMs = dayjs(this.state.options.times.lastTime).diff(this.state.options.times.firstTime, "milliseconds");
      this.state.options.times.totalViewDurationPx = this.state.options.times.totalViewDurationMs / this.state.options.times.timePerPixel;
      this.state.options.width = this.state.options.times.totalViewDurationPx + this.style["grid-line-vertical"]["stroke-width"];
    },
    initTimes() {
      this.state.options.times.firstTime = dayjs(this.state.options.times.firstTaskTime).locale(this.state.options.locale.name).startOf("day").subtract(this.state.options.scope.before, "days").startOf("day").valueOf();
      this.state.options.times.lastTime = dayjs(this.state.options.times.lastTaskTime).locale(this.state.options.locale.name).endOf("day").add(this.state.options.scope.after, "days").endOf("day").valueOf();
      this.recalculateTimes();
    },
    calculateSteps() {
      const steps = [];
      const lastMs = dayjs(this.state.options.times.lastTime).valueOf();
      const currentDate = dayjs(this.state.options.times.firstTime);
      steps.push({
        time: currentDate.valueOf(),
        offset: {
          ms: 0,
          px: 0
        }
      });
      for (let currentDate2 = dayjs(this.state.options.times.firstTime).add(1, this.state.options.times.stepDuration).startOf("day"); currentDate2.valueOf() <= lastMs; currentDate2 = currentDate2.add(1, this.state.options.times.stepDuration).startOf("day")) {
        const offsetMs = currentDate2.diff(this.state.options.times.firstTime, "milliseconds");
        const offsetPx = offsetMs / this.state.options.times.timePerPixel;
        const step = {
          time: currentDate2.valueOf(),
          offset: {
            ms: offsetMs,
            px: offsetPx
          }
        };
        const previousStep = steps[steps.length - 1];
        previousStep.width = {
          ms: offsetMs - previousStep.offset.ms,
          px: offsetPx - previousStep.offset.px
        };
        steps.push(step);
      }
      const lastStep = steps[steps.length - 1];
      lastStep.width = {
        ms: this.state.options.times.totalViewDurationMs - lastStep.offset.ms,
        px: this.state.options.times.totalViewDurationPx - lastStep.offset.px
      };
      this.state.options.times.steps = steps;
    },
    computeCalendarWidths() {
      this.computeDayWidths();
      this.computeHourWidths();
      this.computeMonthWidths();
    },
    computeHourWidths() {
      const style = __spreadValues(__spreadValues({}, this.style["calendar-row-text"]), this.style["calendar-row-text--hour"]);
      this.state.ctx.font = style["font-size"] + " " + style["font-family"];
      const localeName = this.state.options.locale.name;
      let currentDate = dayjs("2018-01-01T00:00:00").locale(localeName);
      let maxWidths = this.state.options.calendar.hour.maxWidths;
      if (maxWidths.length) {
        return;
      }
      for (let formatName in this.state.options.calendar.hour.format) {
        maxWidths[formatName] = 0;
      }
      for (let hour = 0; hour < 24; hour++) {
        let widths = { hour };
        for (let formatName in this.state.options.calendar.hour.format) {
          const hourFormatted = this.state.options.calendar.hour.format[formatName](currentDate);
          this.state.options.calendar.hour.formatted[formatName].push(hourFormatted);
          widths[formatName] = this.state.ctx.measureText(hourFormatted).width;
        }
        this.state.options.calendar.hour.widths.push(widths);
        for (let formatName in this.state.options.calendar.hour.format) {
          if (widths[formatName] > maxWidths[formatName]) {
            maxWidths[formatName] = widths[formatName];
          }
        }
        currentDate = currentDate.add(1, "hour");
      }
    },
    computeDayWidths() {
      const style = __spreadValues(__spreadValues({}, this.style["calendar-row-text"]), this.style["calendar-row-text--day"]);
      this.state.ctx.font = style["font-size"] + " " + style["font-family"];
      const localeName = this.state.options.locale.name;
      let currentDate = dayjs(this.state.options.times.steps[0].time).locale(localeName);
      let maxWidths = this.state.options.calendar.day.maxWidths;
      this.state.options.calendar.day.widths = [];
      Object.keys(this.state.options.calendar.day.format).forEach((formatName) => {
        maxWidths[formatName] = 0;
      });
      for (let day = 0, daysLen = this.state.options.times.steps.length; day < daysLen; day++) {
        const widths = {
          day
        };
        Object.keys(this.state.options.calendar.day.format).forEach((formatName) => {
          widths[formatName] = this.state.ctx.measureText(this.state.options.calendar.day.format[formatName](currentDate)).width;
        });
        this.state.options.calendar.day.widths.push(widths);
        Object.keys(this.state.options.calendar.day.format).forEach((formatName) => {
          if (widths[formatName] > maxWidths[formatName]) {
            maxWidths[formatName] = widths[formatName];
          }
        });
        currentDate = currentDate.add(1, "day");
      }
    },
    monthsCount(fromTime, toTime) {
      if (fromTime > toTime) {
        return 0;
      }
      let currentMonth = dayjs(fromTime);
      let previousMonth = currentMonth.clone();
      let monthsCount = 1;
      while (currentMonth.valueOf() <= toTime) {
        currentMonth = currentMonth.add(1, "day");
        if (previousMonth.month() !== currentMonth.month()) {
          monthsCount++;
        }
        previousMonth = currentMonth.clone();
      }
      return monthsCount;
    },
    computeMonthWidths() {
      const style = __spreadValues(__spreadValues({}, this.style["calendar-row-text"]), this.style["calendar-row-text--month"]);
      this.state.ctx.font = style["font-size"] + " " + style["font-family"];
      let maxWidths = this.state.options.calendar.month.maxWidths;
      this.state.options.calendar.month.widths = [];
      Object.keys(this.state.options.calendar.month.format).forEach((formatName) => {
        maxWidths[formatName] = 0;
      });
      const localeName = this.state.options.locale.name;
      let currentDate = dayjs(this.state.options.times.firstTime).locale(localeName);
      const monthsCount = this.monthsCount(this.state.options.times.firstTime, this.state.options.times.lastTime);
      for (let month = 0; month < monthsCount; month++) {
        const widths = {
          month
        };
        Object.keys(this.state.options.calendar.month.format).forEach((formatName) => {
          widths[formatName] = this.state.ctx.measureText(this.state.options.calendar.month.format[formatName](currentDate)).width;
        });
        this.state.options.calendar.month.widths.push(widths);
        Object.keys(this.state.options.calendar.month.format).forEach((formatName) => {
          if (widths[formatName] > maxWidths[formatName]) {
            maxWidths[formatName] = widths[formatName];
          }
        });
        currentDate = currentDate.add(1, "month");
      }
    },
    prepareDates() {
      let firstTaskTime = Number.MAX_SAFE_INTEGER;
      let lastTaskTime = 0;
      for (let index2 = 0, len = this.state.tasks.length; index2 < len; index2++) {
        let task = this.state.tasks[index2];
        if (task.startTime < firstTaskTime) {
          firstTaskTime = task.startTime;
        }
        if (task.startTime + task.duration > lastTaskTime) {
          lastTaskTime = task.startTime + task.duration;
        }
      }
      this.state.options.times.firstTaskTime = firstTaskTime;
      this.state.options.times.lastTaskTime = lastTaskTime;
      this.state.options.times.firstTime = dayjs(firstTaskTime).locale(this.state.options.locale.name).startOf("day").subtract(this.state.options.scope.before, "days").startOf("day").valueOf();
      this.state.options.times.lastTime = dayjs(lastTaskTime).locale(this.state.options.locale.name).endOf("day").add(this.state.options.scope.after, "days").endOf("day").valueOf();
    },
    setup(itsUpdate = "") {
      this.initialize(itsUpdate);
      this.prepareDates();
      this.initTimes();
      this.calculateSteps();
      this.computeCalendarWidths();
      this.state.options.taskList.width = this.state.options.taskList.columns.reduce((prev, current) => {
        return { width: prev.width + current.width };
      }, { width: 0 }).width;
    },
    globalOnResize() {
      if (typeof this.$el === "undefined" || !this.$el) {
        return;
      }
      this.state.options.clientWidth = this.$el.clientWidth;
      if (this.state.options.taskList.widthFromPercentage > this.state.options.clientWidth / 100 * this.state.options.taskList.widthThreshold) {
        const diff = this.state.options.taskList.widthFromPercentage - this.state.options.clientWidth / 100 * this.state.options.taskList.widthThreshold;
        let diffPercent = 100 - diff / this.state.options.taskList.widthFromPercentage * 100;
        if (diffPercent < 0) {
          diffPercent = 0;
        }
        this.state.options.taskList.columns.forEach((column) => {
          column.thresholdPercent = diffPercent;
        });
      } else {
        this.state.options.taskList.columns.forEach((column) => {
          column.thresholdPercent = 100;
        });
      }
      this.calculateTaskListColumnsDimensions();
      this.$emit("calendar-recalculate");
      this.syncScrollTop();
    },
    taskSetCoordinates(task, index2) {
      task.width = task.duration / this.state.options.times.timePerPixel - this.style["grid-line-vertical"]["stroke-width"];
      if (task.width < 0) {
        task.width = 0;
      }
      task.height = this.state.options.row.height;
      task.x = this.timeToPixelOffsetX(task.startTime);
      task.y = (this.state.options.row.height + this.state.options.chart.grid.horizontal.gap * 2) * index2 + this.state.options.chart.grid.horizontal.gap;
    }
  },
  computed: {
    visibleTasks() {
      const visibleTasks = this.state.tasks.filter((task) => this.isTaskVisible(task));
      const maxRows = visibleTasks.slice(0, this.state.options.maxRows);
      this.state.options.rowsHeight = this.getTasksHeight(maxRows);
      let heightCompensation = 0;
      if (this.state.options.maxHeight && this.state.options.rowsHeight > this.state.options.maxHeight) {
        heightCompensation = this.state.options.rowsHeight - this.state.options.maxHeight;
        this.state.options.rowsHeight = this.state.options.maxHeight;
      }
      this.state.options.height = this.getHeight(maxRows) - heightCompensation;
      this.state.options.allVisibleTasksHeight = this.getTasksHeight(visibleTasks);
      this.state.options.outerHeight = this.getHeight(maxRows, true) - heightCompensation;
      let len = visibleTasks.length;
      console.log("visibleTasks");
      for (let index2 = 0; index2 < len; index2++) {
        let task = visibleTasks[index2];
        if (task.type == "multiple") {
          for (let subIndex = 0; subIndex < task.subTask.length; subIndex++) {
            this.taskSetCoordinates(task.subTask[subIndex], index2);
          }
        } else {
          this.taskSetCoordinates(task, index2);
        }
      }
      return visibleTasks;
    },
    style() {
      return this.state.dynamicStyle;
    },
    getTaskListColumns() {
      this.calculateTaskListColumnsDimensions();
      return this.state.options.taskList.columns;
    },
    outputTasks() {
      return this.state.tasks;
    },
    outputOptions() {
      return this.state.options;
    }
  },
  created() {
    this.$root.emitter = mitt();
    this.initializeEvents();
    this.setup();
    this.state.unwatchTasks = this.$watch("tasks", (tasks) => {
      this.setup("tasks");
    });
    this.state.unwatchOptions = this.$watch("options", (opts) => {
      const notEqual = notEqualDeep(opts, this.outputOptions);
      if (notEqual) {
        this.setup("options");
      }
    }, { deep: true });
    this.state.unwatchStyle = this.$watch("dynamicStyle", (style) => {
      const notEqual = notEqualDeep(style, this.dynamicStyle);
      if (notEqual) {
        this.initializeStyle();
      }
    }, { deep: true, immediate: true });
    this.state.unwatchOutputTasks = this.$watch("outputTasks", (tasks) => {
      this.$emit("tasks-changed", tasks.map((task) => task));
    }, { deep: true });
    this.state.unwatchOutputOptions = this.$watch("outputOptions", (options) => {
      this.$emit("options-changed", mergeDeep({}, options));
    }, { deep: true });
    this.state.unwatchOutputStyle = this.$watch("style", (style) => {
      this.$emit("dynamic-style-changed", mergeDeep({}, style));
    }, { deep: true });
    this.$root.emitter.emit("gantt-elastic-created", this);
    this.$emit("created", this);
  },
  beforeMount() {
    this.$emit("before-mount", this);
  },
  mounted() {
    this.state.options.clientWidth = this.$el.clientWidth;
    this.state.resizeObserver = new index((entries, observer) => {
      this.globalOnResize();
    });
    this.state.resizeObserver.observe(this.$el.parentNode);
    this.globalOnResize();
    this.$emit("ready", this);
    this.$root.emitter.emit("gantt-elastic-mounted", this);
    this.$emit("mounted", this);
    this.$root.emitter.emit("gantt-elastic-ready", this);
  },
  beforeUpdate() {
    this.$emit("before-update");
  },
  updated() {
    this.$nextTick(() => {
      this.$emit("updated");
    });
  },
  beforeDestroy() {
    this.state.resizeObserver.unobserve(this.$el.parentNode);
    this.state.unwatchTasks();
    this.state.unwatchOptions();
    this.state.unwatchStyle();
    this.state.unwatchOutputTasks();
    this.state.unwatchOutputOptions();
    this.state.unwatchOutputStyle();
    this.$emit("before-destroy");
  },
  destroyed() {
    this.$emit("destroyed");
  }
};
var _sfc_main$1 = GanttElastic;
var _hoisted_1$1 = {
  class: "gantt-elastic",
  style: { "width": "100%" }
};
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_main_view = resolveComponent("main-view");
  return openBlock(), createElementBlock("div", _hoisted_1$1, [
    renderSlot(_ctx.$slots, "header"),
    createVNode(_component_main_view, { ref: "mainView" }, null, 512),
    renderSlot(_ctx.$slots, "footer")
  ]);
}
var GanttElastic$1 = _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
function u(t) {
  return [null, void 0, false].indexOf(t) !== -1;
}
function c(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function(e2) {
      return Object.getOwnPropertyDescriptor(t, e2).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function p(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? c(Object(r), true).forEach(function(e2) {
      f$1(t, e2, r[e2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : c(Object(r)).forEach(function(e2) {
      Object.defineProperty(t, e2, Object.getOwnPropertyDescriptor(r, e2));
    });
  }
  return t;
}
function f$1(t, e, r) {
  return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
}
function d(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function h(t) {
  var e = { exports: {} };
  return t(e, e.exports), e.exports;
}
function m(t) {
  return m = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t2) {
    return typeof t2;
  } : function(t2) {
    return t2 && typeof Symbol == "function" && t2.constructor === Symbol && t2 !== Symbol.prototype ? "symbol" : typeof t2;
  }, m(t);
}
var v = h(function(t, e) {
  t.exports = /* @__PURE__ */ function() {
    var t2 = ["decimals", "thousand", "mark", "prefix", "suffix", "encoder", "decoder", "negativeBefore", "negative", "edit", "undo"];
    function e2(t3) {
      return t3.split("").reverse().join("");
    }
    function r(t3, e3) {
      return t3.substring(0, e3.length) === e3;
    }
    function n(t3, e3) {
      return t3.slice(-1 * e3.length) === e3;
    }
    function i(t3, e3, r2) {
      if ((t3[e3] || t3[r2]) && t3[e3] === t3[r2])
        throw new Error(e3);
    }
    function o2(t3) {
      return typeof t3 == "number" && isFinite(t3);
    }
    function a(t3, e3) {
      return t3 = t3.toString().split("e"), (+((t3 = (t3 = Math.round(+(t3[0] + "e" + (t3[1] ? +t3[1] + e3 : e3)))).toString().split("e"))[0] + "e" + (t3[1] ? +t3[1] - e3 : -e3))).toFixed(e3);
    }
    function s2(t3, r2, n2, i2, s3, l2, u3, c3, p3, f2, d2, h2) {
      var m2, v2, g2, b2 = h2, y2 = "", S2 = "";
      return l2 && (h2 = l2(h2)), !!o2(h2) && (t3 !== false && parseFloat(h2.toFixed(t3)) === 0 && (h2 = 0), h2 < 0 && (m2 = true, h2 = Math.abs(h2)), t3 !== false && (h2 = a(h2, t3)), (h2 = h2.toString()).indexOf(".") !== -1 ? (g2 = (v2 = h2.split("."))[0], n2 && (y2 = n2 + v2[1])) : g2 = h2, r2 && (g2 = e2(g2).match(/.{1,3}/g), g2 = e2(g2.join(e2(r2)))), m2 && c3 && (S2 += c3), i2 && (S2 += i2), m2 && p3 && (S2 += p3), S2 += g2, S2 += y2, s3 && (S2 += s3), f2 && (S2 = f2(S2, b2)), S2);
    }
    function l(t3, e3, i2, a2, s3, l2, u3, c3, p3, f2, d2, h2) {
      var m2, v2 = "";
      return d2 && (h2 = d2(h2)), !(!h2 || typeof h2 != "string") && (c3 && r(h2, c3) && (h2 = h2.replace(c3, ""), m2 = true), a2 && r(h2, a2) && (h2 = h2.replace(a2, "")), p3 && r(h2, p3) && (h2 = h2.replace(p3, ""), m2 = true), s3 && n(h2, s3) && (h2 = h2.slice(0, -1 * s3.length)), e3 && (h2 = h2.split(e3).join("")), i2 && (h2 = h2.replace(i2, ".")), m2 && (v2 += "-"), (v2 = (v2 += h2).replace(/[^0-9\.\-.]/g, "")) !== "" && (v2 = Number(v2), u3 && (v2 = u3(v2)), !!o2(v2) && v2));
    }
    function u2(e3) {
      var r2, n2, o3, a2 = {};
      for (e3.suffix === void 0 && (e3.suffix = e3.postfix), r2 = 0; r2 < t2.length; r2 += 1)
        if ((o3 = e3[n2 = t2[r2]]) === void 0)
          n2 !== "negative" || a2.negativeBefore ? n2 === "mark" && a2.thousand !== "." ? a2[n2] = "." : a2[n2] = false : a2[n2] = "-";
        else if (n2 === "decimals") {
          if (!(o3 >= 0 && o3 < 8))
            throw new Error(n2);
          a2[n2] = o3;
        } else if (n2 === "encoder" || n2 === "decoder" || n2 === "edit" || n2 === "undo") {
          if (typeof o3 != "function")
            throw new Error(n2);
          a2[n2] = o3;
        } else {
          if (typeof o3 != "string")
            throw new Error(n2);
          a2[n2] = o3;
        }
      return i(a2, "mark", "thousand"), i(a2, "prefix", "negative"), i(a2, "prefix", "negativeBefore"), a2;
    }
    function c2(e3, r2, n2) {
      var i2, o3 = [];
      for (i2 = 0; i2 < t2.length; i2 += 1)
        o3.push(e3[t2[i2]]);
      return o3.push(n2), r2.apply("", o3);
    }
    function p2(t3) {
      if (!(this instanceof p2))
        return new p2(t3);
      m(t3) === "object" && (t3 = u2(t3), this.to = function(e3) {
        return c2(t3, s2, e3);
      }, this.from = function(e3) {
        return c2(t3, l, e3);
      });
    }
    return p2;
  }();
});
function g(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function(e2) {
      return Object.getOwnPropertyDescriptor(t, e2).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function b$1(t, e, r) {
  return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
}
function y(e, n, i) {
  var o2 = toRefs(e), a = o2.format, s2 = o2.step, l = i.value, u2 = i.classList, c2 = computed(function() {
    return a && a.value ? typeof a.value == "function" ? { to: a.value } : v(function(t) {
      for (var e2 = 1; e2 < arguments.length; e2++) {
        var r = arguments[e2] != null ? arguments[e2] : {};
        e2 % 2 ? g(Object(r), true).forEach(function(e3) {
          b$1(t, e3, r[e3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : g(Object(r)).forEach(function(e3) {
          Object.defineProperty(t, e3, Object.getOwnPropertyDescriptor(r, e3));
        });
      }
      return t;
    }({}, a.value)) : v({ decimals: s2.value >= 0 ? 0 : 2 });
  });
  return { tooltipsFormat: computed(function() {
    return Array.isArray(l.value) ? l.value.map(function(t) {
      return c2.value;
    }) : c2.value;
  }), tooltipsMerge: function(t, e2, r) {
    var n2 = getComputedStyle(t).direction === "rtl", i2 = t.noUiSlider.options.direction === "rtl", o3 = t.noUiSlider.options.orientation === "vertical", a2 = t.noUiSlider.getTooltips(), s3 = t.noUiSlider.getOrigins();
    a2.forEach(function(t2, e3) {
      t2 && s3[e3].appendChild(t2);
    }), t.noUiSlider.on("update", function(t2, s4, l2, p2, f2) {
      var d2 = [[]], h2 = [[]], m2 = [[]], v2 = 0;
      a2[0] && (d2[0][0] = 0, h2[0][0] = f2[0], m2[0][0] = c2.value.to(parseFloat(t2[0])));
      for (var g2 = 1; g2 < t2.length; g2++)
        (!a2[g2] || t2[g2] - t2[g2 - 1] > e2) && (d2[++v2] = [], m2[v2] = [], h2[v2] = []), a2[g2] && (d2[v2].push(g2), m2[v2].push(c2.value.to(parseFloat(t2[g2]))), h2[v2].push(f2[g2]));
      d2.forEach(function(t3, e3) {
        for (var s5 = t3.length, l3 = 0; l3 < s5; l3++) {
          var c3 = t3[l3];
          if (l3 === s5 - 1) {
            var p3 = 0;
            h2[e3].forEach(function(t4) {
              p3 += 1e3 - t4;
            });
            var f3 = o3 ? "bottom" : "right", d3 = i2 ? 0 : s5 - 1, v3 = 1e3 - h2[e3][d3];
            p3 = (n2 && !o3 ? 100 : 0) + p3 / s5 - v3, a2[c3].innerHTML = m2[e3].join(r), a2[c3].style.display = "block", a2[c3].style[f3] = p3 + "%", u2.value.tooltipHidden.split(" ").forEach(function(t4) {
              a2[c3].classList.contains(t4) && a2[c3].classList.remove(t4);
            });
          } else
            a2[c3].style.display = "none", u2.value.tooltipHidden.split(" ").forEach(function(t4) {
              a2[c3].classList.add(t4);
            });
        }
      });
    });
  } };
}
function S(t) {
  return S = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t2) {
    return typeof t2;
  } : function(t2) {
    return t2 && typeof Symbol == "function" && t2.constructor === Symbol && t2 !== Symbol.prototype ? "symbol" : typeof t2;
  }, S(t);
}
var x = d(h(function(t, e) {
  !function(t2) {
    function e2(t3) {
      return r(t3) && typeof t3.from == "function";
    }
    function r(t3) {
      return S(t3) === "object" && typeof t3.to == "function";
    }
    function n(t3) {
      t3.parentElement.removeChild(t3);
    }
    function i(t3) {
      return t3 != null;
    }
    function o2(t3) {
      t3.preventDefault();
    }
    function a(t3) {
      return t3.filter(function(t4) {
        return !this[t4] && (this[t4] = true);
      }, {});
    }
    function s2(t3, e3) {
      return Math.round(t3 / e3) * e3;
    }
    function l(t3, e3) {
      var r2 = t3.getBoundingClientRect(), n2 = t3.ownerDocument, i2 = n2.documentElement, o3 = g2(n2);
      return /webkit.*Chrome.*Mobile/i.test(navigator.userAgent) && (o3.x = 0), e3 ? r2.top + o3.y - i2.clientTop : r2.left + o3.x - i2.clientLeft;
    }
    function u2(t3) {
      return typeof t3 == "number" && !isNaN(t3) && isFinite(t3);
    }
    function c2(t3, e3, r2) {
      r2 > 0 && (h2(t3, e3), setTimeout(function() {
        m2(t3, e3);
      }, r2));
    }
    function p2(t3) {
      return Math.max(Math.min(t3, 100), 0);
    }
    function f2(t3) {
      return Array.isArray(t3) ? t3 : [t3];
    }
    function d2(t3) {
      var e3 = (t3 = String(t3)).split(".");
      return e3.length > 1 ? e3[1].length : 0;
    }
    function h2(t3, e3) {
      t3.classList && !/\s/.test(e3) ? t3.classList.add(e3) : t3.className += " " + e3;
    }
    function m2(t3, e3) {
      t3.classList && !/\s/.test(e3) ? t3.classList.remove(e3) : t3.className = t3.className.replace(new RegExp("(^|\\b)" + e3.split(" ").join("|") + "(\\b|$)", "gi"), " ");
    }
    function v2(t3, e3) {
      return t3.classList ? t3.classList.contains(e3) : new RegExp("\\b" + e3 + "\\b").test(t3.className);
    }
    function g2(t3) {
      var e3 = window.pageXOffset !== void 0, r2 = (t3.compatMode || "") === "CSS1Compat";
      return { x: e3 ? window.pageXOffset : r2 ? t3.documentElement.scrollLeft : t3.body.scrollLeft, y: e3 ? window.pageYOffset : r2 ? t3.documentElement.scrollTop : t3.body.scrollTop };
    }
    function b2() {
      return window.navigator.pointerEnabled ? { start: "pointerdown", move: "pointermove", end: "pointerup" } : window.navigator.msPointerEnabled ? { start: "MSPointerDown", move: "MSPointerMove", end: "MSPointerUp" } : { start: "mousedown touchstart", move: "mousemove touchmove", end: "mouseup touchend" };
    }
    function y2() {
      var t3 = false;
      try {
        var e3 = Object.defineProperty({}, "passive", { get: function() {
          t3 = true;
        } });
        window.addEventListener("test", null, e3);
      } catch (t4) {
      }
      return t3;
    }
    function x2() {
      return window.CSS && CSS.supports && CSS.supports("touch-action", "none");
    }
    function w2(t3, e3) {
      return 100 / (e3 - t3);
    }
    function P2(t3, e3, r2) {
      return 100 * e3 / (t3[r2 + 1] - t3[r2]);
    }
    function E2(t3, e3) {
      return P2(t3, t3[0] < 0 ? e3 + Math.abs(t3[0]) : e3 - t3[0], 0);
    }
    function N(t3, e3) {
      return e3 * (t3[1] - t3[0]) / 100 + t3[0];
    }
    function C(t3, e3) {
      for (var r2 = 1; t3 >= e3[r2]; )
        r2 += 1;
      return r2;
    }
    function O(t3, e3, r2) {
      if (r2 >= t3.slice(-1)[0])
        return 100;
      var n2 = C(r2, t3), i2 = t3[n2 - 1], o3 = t3[n2], a2 = e3[n2 - 1], s3 = e3[n2];
      return a2 + E2([i2, o3], r2) / w2(a2, s3);
    }
    function k(t3, e3, r2) {
      if (r2 >= 100)
        return t3.slice(-1)[0];
      var n2 = C(r2, e3), i2 = t3[n2 - 1], o3 = t3[n2], a2 = e3[n2 - 1];
      return N([i2, o3], (r2 - a2) * w2(a2, e3[n2]));
    }
    function V(t3, e3, r2, n2) {
      if (n2 === 100)
        return n2;
      var i2 = C(n2, t3), o3 = t3[i2 - 1], a2 = t3[i2];
      return r2 ? n2 - o3 > (a2 - o3) / 2 ? a2 : o3 : e3[i2 - 1] ? t3[i2 - 1] + s2(n2 - t3[i2 - 1], e3[i2 - 1]) : n2;
    }
    var A, j;
    t2.PipsMode = void 0, (j = t2.PipsMode || (t2.PipsMode = {})).Range = "range", j.Steps = "steps", j.Positions = "positions", j.Count = "count", j.Values = "values", t2.PipsType = void 0, (A = t2.PipsType || (t2.PipsType = {}))[A.None = -1] = "None", A[A.NoValue = 0] = "NoValue", A[A.LargeValue = 1] = "LargeValue", A[A.SmallValue = 2] = "SmallValue";
    var M = function() {
      function t3(t4, e3, r2) {
        var n2;
        this.xPct = [], this.xVal = [], this.xSteps = [], this.xNumSteps = [], this.xHighestCompleteStep = [], this.xSteps = [r2 || false], this.xNumSteps = [false], this.snap = e3;
        var i2 = [];
        for (Object.keys(t4).forEach(function(e4) {
          i2.push([f2(t4[e4]), e4]);
        }), i2.sort(function(t5, e4) {
          return t5[0][0] - e4[0][0];
        }), n2 = 0; n2 < i2.length; n2++)
          this.handleEntryPoint(i2[n2][1], i2[n2][0]);
        for (this.xNumSteps = this.xSteps.slice(0), n2 = 0; n2 < this.xNumSteps.length; n2++)
          this.handleStepPoint(n2, this.xNumSteps[n2]);
      }
      return t3.prototype.getDistance = function(t4) {
        for (var e3 = [], r2 = 0; r2 < this.xNumSteps.length - 1; r2++)
          e3[r2] = P2(this.xVal, t4, r2);
        return e3;
      }, t3.prototype.getAbsoluteDistance = function(t4, e3, r2) {
        var n2, i2 = 0;
        if (t4 < this.xPct[this.xPct.length - 1])
          for (; t4 > this.xPct[i2 + 1]; )
            i2++;
        else
          t4 === this.xPct[this.xPct.length - 1] && (i2 = this.xPct.length - 2);
        r2 || t4 !== this.xPct[i2 + 1] || i2++, e3 === null && (e3 = []);
        var o3 = 1, a2 = e3[i2], s3 = 0, l2 = 0, u3 = 0, c3 = 0;
        for (n2 = r2 ? (t4 - this.xPct[i2]) / (this.xPct[i2 + 1] - this.xPct[i2]) : (this.xPct[i2 + 1] - t4) / (this.xPct[i2 + 1] - this.xPct[i2]); a2 > 0; )
          s3 = this.xPct[i2 + 1 + c3] - this.xPct[i2 + c3], e3[i2 + c3] * o3 + 100 - 100 * n2 > 100 ? (l2 = s3 * n2, o3 = (a2 - 100 * n2) / e3[i2 + c3], n2 = 1) : (l2 = e3[i2 + c3] * s3 / 100 * o3, o3 = 0), r2 ? (u3 -= l2, this.xPct.length + c3 >= 1 && c3--) : (u3 += l2, this.xPct.length - c3 >= 1 && c3++), a2 = e3[i2 + c3] * o3;
        return t4 + u3;
      }, t3.prototype.toStepping = function(t4) {
        return t4 = O(this.xVal, this.xPct, t4);
      }, t3.prototype.fromStepping = function(t4) {
        return k(this.xVal, this.xPct, t4);
      }, t3.prototype.getStep = function(t4) {
        return t4 = V(this.xPct, this.xSteps, this.snap, t4);
      }, t3.prototype.getDefaultStep = function(t4, e3, r2) {
        var n2 = C(t4, this.xPct);
        return (t4 === 100 || e3 && t4 === this.xPct[n2 - 1]) && (n2 = Math.max(n2 - 1, 1)), (this.xVal[n2] - this.xVal[n2 - 1]) / r2;
      }, t3.prototype.getNearbySteps = function(t4) {
        var e3 = C(t4, this.xPct);
        return { stepBefore: { startValue: this.xVal[e3 - 2], step: this.xNumSteps[e3 - 2], highestStep: this.xHighestCompleteStep[e3 - 2] }, thisStep: { startValue: this.xVal[e3 - 1], step: this.xNumSteps[e3 - 1], highestStep: this.xHighestCompleteStep[e3 - 1] }, stepAfter: { startValue: this.xVal[e3], step: this.xNumSteps[e3], highestStep: this.xHighestCompleteStep[e3] } };
      }, t3.prototype.countStepDecimals = function() {
        var t4 = this.xNumSteps.map(d2);
        return Math.max.apply(null, t4);
      }, t3.prototype.hasNoSize = function() {
        return this.xVal[0] === this.xVal[this.xVal.length - 1];
      }, t3.prototype.convert = function(t4) {
        return this.getStep(this.toStepping(t4));
      }, t3.prototype.handleEntryPoint = function(t4, e3) {
        var r2;
        if (!u2(r2 = t4 === "min" ? 0 : t4 === "max" ? 100 : parseFloat(t4)) || !u2(e3[0]))
          throw new Error("noUiSlider: 'range' value isn't numeric.");
        this.xPct.push(r2), this.xVal.push(e3[0]);
        var n2 = Number(e3[1]);
        r2 ? this.xSteps.push(!isNaN(n2) && n2) : isNaN(n2) || (this.xSteps[0] = n2), this.xHighestCompleteStep.push(0);
      }, t3.prototype.handleStepPoint = function(t4, e3) {
        if (e3)
          if (this.xVal[t4] !== this.xVal[t4 + 1]) {
            this.xSteps[t4] = P2([this.xVal[t4], this.xVal[t4 + 1]], e3, 0) / w2(this.xPct[t4], this.xPct[t4 + 1]);
            var r2 = (this.xVal[t4 + 1] - this.xVal[t4]) / this.xNumSteps[t4], n2 = Math.ceil(Number(r2.toFixed(3)) - 1), i2 = this.xVal[t4] + this.xNumSteps[t4] * n2;
            this.xHighestCompleteStep[t4] = i2;
          } else
            this.xSteps[t4] = this.xHighestCompleteStep[t4] = this.xVal[t4];
      }, t3;
    }(), U = { to: function(t3) {
      return t3 === void 0 ? "" : t3.toFixed(2);
    }, from: Number }, D = { target: "target", base: "base", origin: "origin", handle: "handle", handleLower: "handle-lower", handleUpper: "handle-upper", touchArea: "touch-area", horizontal: "horizontal", vertical: "vertical", background: "background", connect: "connect", connects: "connects", ltr: "ltr", rtl: "rtl", textDirectionLtr: "txt-dir-ltr", textDirectionRtl: "txt-dir-rtl", draggable: "draggable", drag: "state-drag", tap: "state-tap", active: "active", tooltip: "tooltip", pips: "pips", pipsHorizontal: "pips-horizontal", pipsVertical: "pips-vertical", marker: "marker", markerHorizontal: "marker-horizontal", markerVertical: "marker-vertical", markerNormal: "marker-normal", markerLarge: "marker-large", markerSub: "marker-sub", value: "value", valueHorizontal: "value-horizontal", valueVertical: "value-vertical", valueNormal: "value-normal", valueLarge: "value-large", valueSub: "value-sub" }, L = { tooltips: ".__tooltips", aria: ".__aria" };
    function T(t3, e3) {
      if (!u2(e3))
        throw new Error("noUiSlider: 'step' is not numeric.");
      t3.singleStep = e3;
    }
    function z(t3, e3) {
      if (!u2(e3))
        throw new Error("noUiSlider: 'keyboardPageMultiplier' is not numeric.");
      t3.keyboardPageMultiplier = e3;
    }
    function F(t3, e3) {
      if (!u2(e3))
        throw new Error("noUiSlider: 'keyboardMultiplier' is not numeric.");
      t3.keyboardMultiplier = e3;
    }
    function H(t3, e3) {
      if (!u2(e3))
        throw new Error("noUiSlider: 'keyboardDefaultStep' is not numeric.");
      t3.keyboardDefaultStep = e3;
    }
    function q(t3, e3) {
      if (S(e3) !== "object" || Array.isArray(e3))
        throw new Error("noUiSlider: 'range' is not an object.");
      if (e3.min === void 0 || e3.max === void 0)
        throw new Error("noUiSlider: Missing 'min' or 'max' in 'range'.");
      t3.spectrum = new M(e3, t3.snap || false, t3.singleStep);
    }
    function R(t3, e3) {
      if (e3 = f2(e3), !Array.isArray(e3) || !e3.length)
        throw new Error("noUiSlider: 'start' option is incorrect.");
      t3.handles = e3.length, t3.start = e3;
    }
    function B(t3, e3) {
      if (typeof e3 != "boolean")
        throw new Error("noUiSlider: 'snap' option must be a boolean.");
      t3.snap = e3;
    }
    function _(t3, e3) {
      if (typeof e3 != "boolean")
        throw new Error("noUiSlider: 'animate' option must be a boolean.");
      t3.animate = e3;
    }
    function X(t3, e3) {
      if (typeof e3 != "number")
        throw new Error("noUiSlider: 'animationDuration' option must be a number.");
      t3.animationDuration = e3;
    }
    function Y(t3, e3) {
      var r2, n2 = [false];
      if (e3 === "lower" ? e3 = [true, false] : e3 === "upper" && (e3 = [false, true]), e3 === true || e3 === false) {
        for (r2 = 1; r2 < t3.handles; r2++)
          n2.push(e3);
        n2.push(false);
      } else {
        if (!Array.isArray(e3) || !e3.length || e3.length !== t3.handles + 1)
          throw new Error("noUiSlider: 'connect' option doesn't match handle count.");
        n2 = e3;
      }
      t3.connect = n2;
    }
    function I(t3, e3) {
      switch (e3) {
        case "horizontal":
          t3.ort = 0;
          break;
        case "vertical":
          t3.ort = 1;
          break;
        default:
          throw new Error("noUiSlider: 'orientation' option is invalid.");
      }
    }
    function $(t3, e3) {
      if (!u2(e3))
        throw new Error("noUiSlider: 'margin' option must be numeric.");
      e3 !== 0 && (t3.margin = t3.spectrum.getDistance(e3));
    }
    function W(t3, e3) {
      if (!u2(e3))
        throw new Error("noUiSlider: 'limit' option must be numeric.");
      if (t3.limit = t3.spectrum.getDistance(e3), !t3.limit || t3.handles < 2)
        throw new Error("noUiSlider: 'limit' option is only supported on linear sliders with 2 or more handles.");
    }
    function G(t3, e3) {
      var r2;
      if (!u2(e3) && !Array.isArray(e3))
        throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.");
      if (Array.isArray(e3) && e3.length !== 2 && !u2(e3[0]) && !u2(e3[1]))
        throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.");
      if (e3 !== 0) {
        for (Array.isArray(e3) || (e3 = [e3, e3]), t3.padding = [t3.spectrum.getDistance(e3[0]), t3.spectrum.getDistance(e3[1])], r2 = 0; r2 < t3.spectrum.xNumSteps.length - 1; r2++)
          if (t3.padding[0][r2] < 0 || t3.padding[1][r2] < 0)
            throw new Error("noUiSlider: 'padding' option must be a positive number(s).");
        var n2 = e3[0] + e3[1], i2 = t3.spectrum.xVal[0];
        if (n2 / (t3.spectrum.xVal[t3.spectrum.xVal.length - 1] - i2) > 1)
          throw new Error("noUiSlider: 'padding' option must not exceed 100% of the range.");
      }
    }
    function J(t3, e3) {
      switch (e3) {
        case "ltr":
          t3.dir = 0;
          break;
        case "rtl":
          t3.dir = 1;
          break;
        default:
          throw new Error("noUiSlider: 'direction' option was not recognized.");
      }
    }
    function K(t3, e3) {
      if (typeof e3 != "string")
        throw new Error("noUiSlider: 'behaviour' must be a string containing options.");
      var r2 = e3.indexOf("tap") >= 0, n2 = e3.indexOf("drag") >= 0, i2 = e3.indexOf("fixed") >= 0, o3 = e3.indexOf("snap") >= 0, a2 = e3.indexOf("hover") >= 0, s3 = e3.indexOf("unconstrained") >= 0, l2 = e3.indexOf("drag-all") >= 0;
      if (i2) {
        if (t3.handles !== 2)
          throw new Error("noUiSlider: 'fixed' behaviour must be used with 2 handles");
        $(t3, t3.start[1] - t3.start[0]);
      }
      if (s3 && (t3.margin || t3.limit))
        throw new Error("noUiSlider: 'unconstrained' behaviour cannot be used with margin or limit");
      t3.events = { tap: r2 || o3, drag: n2, dragAll: l2, fixed: i2, snap: o3, hover: a2, unconstrained: s3 };
    }
    function Q(t3, e3) {
      if (e3 !== false)
        if (e3 === true || r(e3)) {
          t3.tooltips = [];
          for (var n2 = 0; n2 < t3.handles; n2++)
            t3.tooltips.push(e3);
        } else {
          if ((e3 = f2(e3)).length !== t3.handles)
            throw new Error("noUiSlider: must pass a formatter for all handles.");
          e3.forEach(function(t4) {
            if (typeof t4 != "boolean" && !r(t4))
              throw new Error("noUiSlider: 'tooltips' must be passed a formatter or 'false'.");
          }), t3.tooltips = e3;
        }
    }
    function Z(t3, e3) {
      if (e3.length !== t3.handles)
        throw new Error("noUiSlider: must pass a attributes for all handles.");
      t3.handleAttributes = e3;
    }
    function tt(t3, e3) {
      if (!r(e3))
        throw new Error("noUiSlider: 'ariaFormat' requires 'to' method.");
      t3.ariaFormat = e3;
    }
    function et(t3, r2) {
      if (!e2(r2))
        throw new Error("noUiSlider: 'format' requires 'to' and 'from' methods.");
      t3.format = r2;
    }
    function rt(t3, e3) {
      if (typeof e3 != "boolean")
        throw new Error("noUiSlider: 'keyboardSupport' option must be a boolean.");
      t3.keyboardSupport = e3;
    }
    function nt(t3, e3) {
      t3.documentElement = e3;
    }
    function it(t3, e3) {
      if (typeof e3 != "string" && e3 !== false)
        throw new Error("noUiSlider: 'cssPrefix' must be a string or `false`.");
      t3.cssPrefix = e3;
    }
    function ot(t3, e3) {
      if (S(e3) !== "object")
        throw new Error("noUiSlider: 'cssClasses' must be an object.");
      typeof t3.cssPrefix == "string" ? (t3.cssClasses = {}, Object.keys(e3).forEach(function(r2) {
        t3.cssClasses[r2] = t3.cssPrefix + e3[r2];
      })) : t3.cssClasses = e3;
    }
    function at(t3) {
      var e3 = { margin: null, limit: null, padding: null, animate: true, animationDuration: 300, ariaFormat: U, format: U }, r2 = { step: { r: false, t: T }, keyboardPageMultiplier: { r: false, t: z }, keyboardMultiplier: { r: false, t: F }, keyboardDefaultStep: { r: false, t: H }, start: { r: true, t: R }, connect: { r: true, t: Y }, direction: { r: true, t: J }, snap: { r: false, t: B }, animate: { r: false, t: _ }, animationDuration: { r: false, t: X }, range: { r: true, t: q }, orientation: { r: false, t: I }, margin: { r: false, t: $ }, limit: { r: false, t: W }, padding: { r: false, t: G }, behaviour: { r: true, t: K }, ariaFormat: { r: false, t: tt }, format: { r: false, t: et }, tooltips: { r: false, t: Q }, keyboardSupport: { r: true, t: rt }, documentElement: { r: false, t: nt }, cssPrefix: { r: true, t: it }, cssClasses: { r: true, t: ot }, handleAttributes: { r: false, t: Z } }, n2 = { connect: false, direction: "ltr", behaviour: "tap", orientation: "horizontal", keyboardSupport: true, cssPrefix: "noUi-", cssClasses: D, keyboardPageMultiplier: 5, keyboardMultiplier: 1, keyboardDefaultStep: 10 };
      t3.format && !t3.ariaFormat && (t3.ariaFormat = t3.format), Object.keys(r2).forEach(function(o4) {
        if (i(t3[o4]) || n2[o4] !== void 0)
          r2[o4].t(e3, i(t3[o4]) ? t3[o4] : n2[o4]);
        else if (r2[o4].r)
          throw new Error("noUiSlider: '" + o4 + "' is required.");
      }), e3.pips = t3.pips;
      var o3 = document.createElement("div"), a2 = o3.style.msTransform !== void 0, s3 = o3.style.transform !== void 0;
      e3.transformRule = s3 ? "transform" : a2 ? "msTransform" : "webkitTransform";
      var l2 = [["left", "top"], ["right", "bottom"]];
      return e3.style = l2[e3.dir][e3.ort], e3;
    }
    function st(e3, r2, s3) {
      var u3, d3, S2, w3, P3, E3 = b2(), N2 = x2() && y2(), C2 = e3, O2 = r2.spectrum, k2 = [], V2 = [], A2 = [], j2 = 0, M2 = {}, U2 = e3.ownerDocument, D2 = r2.documentElement || U2.documentElement, T2 = U2.body, z2 = U2.dir === "rtl" || r2.ort === 1 ? 0 : 100;
      function F2(t3, e4) {
        var r3 = U2.createElement("div");
        return e4 && h2(r3, e4), t3.appendChild(r3), r3;
      }
      function H2(t3, e4) {
        var n2 = F2(t3, r2.cssClasses.origin), i2 = F2(n2, r2.cssClasses.handle);
        if (F2(i2, r2.cssClasses.touchArea), i2.setAttribute("data-handle", String(e4)), r2.keyboardSupport && (i2.setAttribute("tabindex", "0"), i2.addEventListener("keydown", function(t4) {
          return dt(t4, e4);
        })), r2.handleAttributes !== void 0) {
          var o3 = r2.handleAttributes[e4];
          Object.keys(o3).forEach(function(t4) {
            i2.setAttribute(t4, o3[t4]);
          });
        }
        return i2.setAttribute("role", "slider"), i2.setAttribute("aria-orientation", r2.ort ? "vertical" : "horizontal"), e4 === 0 ? h2(i2, r2.cssClasses.handleLower) : e4 === r2.handles - 1 && h2(i2, r2.cssClasses.handleUpper), n2;
      }
      function q2(t3, e4) {
        return !!e4 && F2(t3, r2.cssClasses.connect);
      }
      function R2(t3, e4) {
        var n2 = F2(e4, r2.cssClasses.connects);
        d3 = [], (S2 = []).push(q2(n2, t3[0]));
        for (var i2 = 0; i2 < r2.handles; i2++)
          d3.push(H2(e4, i2)), A2[i2] = i2, S2.push(q2(n2, t3[i2 + 1]));
      }
      function B2(t3) {
        return h2(t3, r2.cssClasses.target), r2.dir === 0 ? h2(t3, r2.cssClasses.ltr) : h2(t3, r2.cssClasses.rtl), r2.ort === 0 ? h2(t3, r2.cssClasses.horizontal) : h2(t3, r2.cssClasses.vertical), h2(t3, getComputedStyle(t3).direction === "rtl" ? r2.cssClasses.textDirectionRtl : r2.cssClasses.textDirectionLtr), F2(t3, r2.cssClasses.base);
      }
      function _2(t3, e4) {
        return !(!r2.tooltips || !r2.tooltips[e4]) && F2(t3.firstChild, r2.cssClasses.tooltip);
      }
      function X2() {
        return C2.hasAttribute("disabled");
      }
      function Y2(t3) {
        return d3[t3].hasAttribute("disabled");
      }
      function I2() {
        P3 && (gt("update" + L.tooltips), P3.forEach(function(t3) {
          t3 && n(t3);
        }), P3 = null);
      }
      function $2() {
        I2(), P3 = d3.map(_2), mt("update" + L.tooltips, function(t3, e4, n2) {
          if (P3 && r2.tooltips && P3[e4] !== false) {
            var i2 = t3[e4];
            r2.tooltips[e4] !== true && (i2 = r2.tooltips[e4].to(n2[e4])), P3[e4].innerHTML = i2;
          }
        });
      }
      function W2() {
        gt("update" + L.aria), mt("update" + L.aria, function(t3, e4, n2, i2, o3) {
          A2.forEach(function(t4) {
            var e5 = d3[t4], i3 = yt(V2, t4, 0, true, true, true), a2 = yt(V2, t4, 100, true, true, true), s4 = o3[t4], l2 = String(r2.ariaFormat.to(n2[t4]));
            i3 = O2.fromStepping(i3).toFixed(1), a2 = O2.fromStepping(a2).toFixed(1), s4 = O2.fromStepping(s4).toFixed(1), e5.children[0].setAttribute("aria-valuemin", i3), e5.children[0].setAttribute("aria-valuemax", a2), e5.children[0].setAttribute("aria-valuenow", s4), e5.children[0].setAttribute("aria-valuetext", l2);
          });
        });
      }
      function G2(e4) {
        if (e4.mode === t2.PipsMode.Range || e4.mode === t2.PipsMode.Steps)
          return O2.xVal;
        if (e4.mode === t2.PipsMode.Count) {
          if (e4.values < 2)
            throw new Error("noUiSlider: 'values' (>= 2) required for mode 'count'.");
          for (var r3 = e4.values - 1, n2 = 100 / r3, i2 = []; r3--; )
            i2[r3] = r3 * n2;
          return i2.push(100), J2(i2, e4.stepped);
        }
        return e4.mode === t2.PipsMode.Positions ? J2(e4.values, e4.stepped) : e4.mode === t2.PipsMode.Values ? e4.stepped ? e4.values.map(function(t3) {
          return O2.fromStepping(O2.getStep(O2.toStepping(t3)));
        }) : e4.values : [];
      }
      function J2(t3, e4) {
        return t3.map(function(t4) {
          return O2.fromStepping(e4 ? O2.getStep(t4) : t4);
        });
      }
      function K2(e4) {
        function r3(t3, e5) {
          return Number((t3 + e5).toFixed(7));
        }
        var n2 = G2(e4), i2 = {}, o3 = O2.xVal[0], s4 = O2.xVal[O2.xVal.length - 1], l2 = false, u4 = false, c3 = 0;
        return (n2 = a(n2.slice().sort(function(t3, e5) {
          return t3 - e5;
        })))[0] !== o3 && (n2.unshift(o3), l2 = true), n2[n2.length - 1] !== s4 && (n2.push(s4), u4 = true), n2.forEach(function(o4, a2) {
          var s5, p3, f3, d4, h3, m3, v3, g3, b3, y3, S3 = o4, x3 = n2[a2 + 1], w4 = e4.mode === t2.PipsMode.Steps;
          for (w4 && (s5 = O2.xNumSteps[a2]), s5 || (s5 = x3 - S3), x3 === void 0 && (x3 = S3), s5 = Math.max(s5, 1e-7), p3 = S3; p3 <= x3; p3 = r3(p3, s5)) {
            for (g3 = (h3 = (d4 = O2.toStepping(p3)) - c3) / (e4.density || 1), y3 = h3 / (b3 = Math.round(g3)), f3 = 1; f3 <= b3; f3 += 1)
              i2[(m3 = c3 + f3 * y3).toFixed(5)] = [O2.fromStepping(m3), 0];
            v3 = n2.indexOf(p3) > -1 ? t2.PipsType.LargeValue : w4 ? t2.PipsType.SmallValue : t2.PipsType.NoValue, !a2 && l2 && p3 !== x3 && (v3 = 0), p3 === x3 && u4 || (i2[d4.toFixed(5)] = [p3, v3]), c3 = d4;
          }
        }), i2;
      }
      function Q2(e4, n2, i2) {
        var o3, a2, s4 = U2.createElement("div"), l2 = ((o3 = {})[t2.PipsType.None] = "", o3[t2.PipsType.NoValue] = r2.cssClasses.valueNormal, o3[t2.PipsType.LargeValue] = r2.cssClasses.valueLarge, o3[t2.PipsType.SmallValue] = r2.cssClasses.valueSub, o3), u4 = ((a2 = {})[t2.PipsType.None] = "", a2[t2.PipsType.NoValue] = r2.cssClasses.markerNormal, a2[t2.PipsType.LargeValue] = r2.cssClasses.markerLarge, a2[t2.PipsType.SmallValue] = r2.cssClasses.markerSub, a2), c3 = [r2.cssClasses.valueHorizontal, r2.cssClasses.valueVertical], p3 = [r2.cssClasses.markerHorizontal, r2.cssClasses.markerVertical];
        function f3(t3, e5) {
          var n3 = e5 === r2.cssClasses.value, i3 = n3 ? l2 : u4;
          return e5 + " " + (n3 ? c3 : p3)[r2.ort] + " " + i3[t3];
        }
        function d4(e5, o4, a3) {
          if ((a3 = n2 ? n2(o4, a3) : a3) !== t2.PipsType.None) {
            var l3 = F2(s4, false);
            l3.className = f3(a3, r2.cssClasses.marker), l3.style[r2.style] = e5 + "%", a3 > t2.PipsType.NoValue && ((l3 = F2(s4, false)).className = f3(a3, r2.cssClasses.value), l3.setAttribute("data-value", String(o4)), l3.style[r2.style] = e5 + "%", l3.innerHTML = String(i2.to(o4)));
          }
        }
        return h2(s4, r2.cssClasses.pips), h2(s4, r2.ort === 0 ? r2.cssClasses.pipsHorizontal : r2.cssClasses.pipsVertical), Object.keys(e4).forEach(function(t3) {
          d4(t3, e4[t3][0], e4[t3][1]);
        }), s4;
      }
      function Z2() {
        w3 && (n(w3), w3 = null);
      }
      function tt2(t3) {
        Z2();
        var e4 = K2(t3), r3 = t3.filter, n2 = t3.format || { to: function(t4) {
          return String(Math.round(t4));
        } };
        return w3 = C2.appendChild(Q2(e4, r3, n2));
      }
      function et2() {
        var t3 = u3.getBoundingClientRect(), e4 = "offset" + ["Width", "Height"][r2.ort];
        return r2.ort === 0 ? t3.width || u3[e4] : t3.height || u3[e4];
      }
      function rt2(t3, e4, n2, i2) {
        var o3 = function(o4) {
          var a3 = nt2(o4, i2.pageOffset, i2.target || e4);
          return !!a3 && !(X2() && !i2.doNotReject) && !(v2(C2, r2.cssClasses.tap) && !i2.doNotReject) && !(t3 === E3.start && a3.buttons !== void 0 && a3.buttons > 1) && (!i2.hover || !a3.buttons) && (N2 || a3.preventDefault(), a3.calcPoint = a3.points[r2.ort], void n2(a3, i2));
        }, a2 = [];
        return t3.split(" ").forEach(function(t4) {
          e4.addEventListener(t4, o3, !!N2 && { passive: true }), a2.push([t4, o3]);
        }), a2;
      }
      function nt2(t3, e4, r3) {
        var n2 = t3.type.indexOf("touch") === 0, i2 = t3.type.indexOf("mouse") === 0, o3 = t3.type.indexOf("pointer") === 0, a2 = 0, s4 = 0;
        if (t3.type.indexOf("MSPointer") === 0 && (o3 = true), t3.type === "mousedown" && !t3.buttons && !t3.touches)
          return false;
        if (n2) {
          var l2 = function(e5) {
            var n3 = e5.target;
            return n3 === r3 || r3.contains(n3) || t3.composed && t3.composedPath().shift() === r3;
          };
          if (t3.type === "touchstart") {
            var u4 = Array.prototype.filter.call(t3.touches, l2);
            if (u4.length > 1)
              return false;
            a2 = u4[0].pageX, s4 = u4[0].pageY;
          } else {
            var c3 = Array.prototype.find.call(t3.changedTouches, l2);
            if (!c3)
              return false;
            a2 = c3.pageX, s4 = c3.pageY;
          }
        }
        return e4 = e4 || g2(U2), (i2 || o3) && (a2 = t3.clientX + e4.x, s4 = t3.clientY + e4.y), t3.pageOffset = e4, t3.points = [a2, s4], t3.cursor = i2 || o3, t3;
      }
      function it2(t3) {
        var e4 = 100 * (t3 - l(u3, r2.ort)) / et2();
        return e4 = p2(e4), r2.dir ? 100 - e4 : e4;
      }
      function ot2(t3) {
        var e4 = 100, r3 = false;
        return d3.forEach(function(n2, i2) {
          if (!Y2(i2)) {
            var o3 = V2[i2], a2 = Math.abs(o3 - t3);
            (a2 < e4 || a2 <= e4 && t3 > o3 || a2 === 100 && e4 === 100) && (r3 = i2, e4 = a2);
          }
        }), r3;
      }
      function st2(t3, e4) {
        t3.type === "mouseout" && t3.target.nodeName === "HTML" && t3.relatedTarget === null && ut2(t3, e4);
      }
      function lt2(t3, e4) {
        if (navigator.appVersion.indexOf("MSIE 9") === -1 && t3.buttons === 0 && e4.buttonsProperty !== 0)
          return ut2(t3, e4);
        var n2 = (r2.dir ? -1 : 1) * (t3.calcPoint - e4.startCalcPoint);
        xt(n2 > 0, 100 * n2 / e4.baseSize, e4.locations, e4.handleNumbers, e4.connect);
      }
      function ut2(t3, e4) {
        e4.handle && (m2(e4.handle, r2.cssClasses.active), j2 -= 1), e4.listeners.forEach(function(t4) {
          D2.removeEventListener(t4[0], t4[1]);
        }), j2 === 0 && (m2(C2, r2.cssClasses.drag), Et(), t3.cursor && (T2.style.cursor = "", T2.removeEventListener("selectstart", o2))), e4.handleNumbers.forEach(function(t4) {
          bt("change", t4), bt("set", t4), bt("end", t4);
        });
      }
      function ct(t3, e4) {
        if (!e4.handleNumbers.some(Y2)) {
          var n2;
          e4.handleNumbers.length === 1 && (n2 = d3[e4.handleNumbers[0]].children[0], j2 += 1, h2(n2, r2.cssClasses.active)), t3.stopPropagation();
          var i2 = [], a2 = rt2(E3.move, D2, lt2, { target: t3.target, handle: n2, connect: e4.connect, listeners: i2, startCalcPoint: t3.calcPoint, baseSize: et2(), pageOffset: t3.pageOffset, handleNumbers: e4.handleNumbers, buttonsProperty: t3.buttons, locations: V2.slice() }), s4 = rt2(E3.end, D2, ut2, { target: t3.target, handle: n2, listeners: i2, doNotReject: true, handleNumbers: e4.handleNumbers }), l2 = rt2("mouseout", D2, st2, { target: t3.target, handle: n2, listeners: i2, doNotReject: true, handleNumbers: e4.handleNumbers });
          i2.push.apply(i2, a2.concat(s4, l2)), t3.cursor && (T2.style.cursor = getComputedStyle(t3.target).cursor, d3.length > 1 && h2(C2, r2.cssClasses.drag), T2.addEventListener("selectstart", o2, false)), e4.handleNumbers.forEach(function(t4) {
            bt("start", t4);
          });
        }
      }
      function pt(t3) {
        t3.stopPropagation();
        var e4 = it2(t3.calcPoint), n2 = ot2(e4);
        n2 !== false && (r2.events.snap || c2(C2, r2.cssClasses.tap, r2.animationDuration), Nt(n2, e4, true, true), Et(), bt("slide", n2, true), bt("update", n2, true), r2.events.snap ? ct(t3, { handleNumbers: [n2] }) : (bt("change", n2, true), bt("set", n2, true)));
      }
      function ft(t3) {
        var e4 = it2(t3.calcPoint), r3 = O2.getStep(e4), n2 = O2.fromStepping(r3);
        Object.keys(M2).forEach(function(t4) {
          t4.split(".")[0] === "hover" && M2[t4].forEach(function(t5) {
            t5.call(zt, n2);
          });
        });
      }
      function dt(t3, e4) {
        if (X2() || Y2(e4))
          return false;
        var n2 = ["Left", "Right"], i2 = ["Down", "Up"], o3 = ["PageDown", "PageUp"], a2 = ["Home", "End"];
        r2.dir && !r2.ort ? n2.reverse() : r2.ort && !r2.dir && (i2.reverse(), o3.reverse());
        var s4, l2 = t3.key.replace("Arrow", ""), u4 = l2 === o3[0], c3 = l2 === o3[1], p3 = l2 === i2[0] || l2 === n2[0] || u4, f3 = l2 === i2[1] || l2 === n2[1] || c3, d4 = l2 === a2[0], h3 = l2 === a2[1];
        if (!(p3 || f3 || d4 || h3))
          return true;
        if (t3.preventDefault(), f3 || p3) {
          var m3 = p3 ? 0 : 1, v3 = Ut(e4)[m3];
          if (v3 === null)
            return false;
          v3 === false && (v3 = O2.getDefaultStep(V2[e4], p3, r2.keyboardDefaultStep)), v3 *= c3 || u4 ? r2.keyboardPageMultiplier : r2.keyboardMultiplier, v3 = Math.max(v3, 1e-7), v3 *= p3 ? -1 : 1, s4 = k2[e4] + v3;
        } else
          s4 = h3 ? r2.spectrum.xVal[r2.spectrum.xVal.length - 1] : r2.spectrum.xVal[0];
        return Nt(e4, O2.toStepping(s4), true, true), bt("slide", e4), bt("update", e4), bt("change", e4), bt("set", e4), false;
      }
      function ht(t3) {
        t3.fixed || d3.forEach(function(t4, e4) {
          rt2(E3.start, t4.children[0], ct, { handleNumbers: [e4] });
        }), t3.tap && rt2(E3.start, u3, pt, {}), t3.hover && rt2(E3.move, u3, ft, { hover: true }), t3.drag && S2.forEach(function(e4, n2) {
          if (e4 !== false && n2 !== 0 && n2 !== S2.length - 1) {
            var i2 = d3[n2 - 1], o3 = d3[n2], a2 = [e4], s4 = [i2, o3], l2 = [n2 - 1, n2];
            h2(e4, r2.cssClasses.draggable), t3.fixed && (a2.push(i2.children[0]), a2.push(o3.children[0])), t3.dragAll && (s4 = d3, l2 = A2), a2.forEach(function(t4) {
              rt2(E3.start, t4, ct, { handles: s4, handleNumbers: l2, connect: e4 });
            });
          }
        });
      }
      function mt(t3, e4) {
        M2[t3] = M2[t3] || [], M2[t3].push(e4), t3.split(".")[0] === "update" && d3.forEach(function(t4, e5) {
          bt("update", e5);
        });
      }
      function vt(t3) {
        return t3 === L.aria || t3 === L.tooltips;
      }
      function gt(t3) {
        var e4 = t3 && t3.split(".")[0], r3 = e4 ? t3.substring(e4.length) : t3;
        Object.keys(M2).forEach(function(t4) {
          var n2 = t4.split(".")[0], i2 = t4.substring(n2.length);
          e4 && e4 !== n2 || r3 && r3 !== i2 || vt(i2) && r3 !== i2 || delete M2[t4];
        });
      }
      function bt(t3, e4, n2) {
        Object.keys(M2).forEach(function(i2) {
          var o3 = i2.split(".")[0];
          t3 === o3 && M2[i2].forEach(function(t4) {
            t4.call(zt, k2.map(r2.format.to), e4, k2.slice(), n2 || false, V2.slice(), zt);
          });
        });
      }
      function yt(t3, e4, n2, i2, o3, a2) {
        var s4;
        return d3.length > 1 && !r2.events.unconstrained && (i2 && e4 > 0 && (s4 = O2.getAbsoluteDistance(t3[e4 - 1], r2.margin, false), n2 = Math.max(n2, s4)), o3 && e4 < d3.length - 1 && (s4 = O2.getAbsoluteDistance(t3[e4 + 1], r2.margin, true), n2 = Math.min(n2, s4))), d3.length > 1 && r2.limit && (i2 && e4 > 0 && (s4 = O2.getAbsoluteDistance(t3[e4 - 1], r2.limit, false), n2 = Math.min(n2, s4)), o3 && e4 < d3.length - 1 && (s4 = O2.getAbsoluteDistance(t3[e4 + 1], r2.limit, true), n2 = Math.max(n2, s4))), r2.padding && (e4 === 0 && (s4 = O2.getAbsoluteDistance(0, r2.padding[0], false), n2 = Math.max(n2, s4)), e4 === d3.length - 1 && (s4 = O2.getAbsoluteDistance(100, r2.padding[1], true), n2 = Math.min(n2, s4))), !((n2 = p2(n2 = O2.getStep(n2))) === t3[e4] && !a2) && n2;
      }
      function St(t3, e4) {
        var n2 = r2.ort;
        return (n2 ? e4 : t3) + ", " + (n2 ? t3 : e4);
      }
      function xt(t3, e4, r3, n2, i2) {
        var o3 = r3.slice(), a2 = n2[0], s4 = [!t3, t3], l2 = [t3, !t3];
        n2 = n2.slice(), t3 && n2.reverse(), n2.length > 1 ? n2.forEach(function(t4, r4) {
          var n3 = yt(o3, t4, o3[t4] + e4, s4[r4], l2[r4], false);
          n3 === false ? e4 = 0 : (e4 = n3 - o3[t4], o3[t4] = n3);
        }) : s4 = l2 = [true];
        var u4 = false;
        n2.forEach(function(t4, n3) {
          u4 = Nt(t4, r3[t4] + e4, s4[n3], l2[n3]) || u4;
        }), u4 && (n2.forEach(function(t4) {
          bt("update", t4), bt("slide", t4);
        }), i2 != null && bt("drag", a2));
      }
      function wt(t3, e4) {
        return r2.dir ? 100 - t3 - e4 : t3;
      }
      function Pt(t3, e4) {
        V2[t3] = e4, k2[t3] = O2.fromStepping(e4);
        var n2 = "translate(" + St(wt(e4, 0) - z2 + "%", "0") + ")";
        d3[t3].style[r2.transformRule] = n2, Ct(t3), Ct(t3 + 1);
      }
      function Et() {
        A2.forEach(function(t3) {
          var e4 = V2[t3] > 50 ? -1 : 1, r3 = 3 + (d3.length + e4 * t3);
          d3[t3].style.zIndex = String(r3);
        });
      }
      function Nt(t3, e4, r3, n2, i2) {
        return i2 || (e4 = yt(V2, t3, e4, r3, n2, false)), e4 !== false && (Pt(t3, e4), true);
      }
      function Ct(t3) {
        if (S2[t3]) {
          var e4 = 0, n2 = 100;
          t3 !== 0 && (e4 = V2[t3 - 1]), t3 !== S2.length - 1 && (n2 = V2[t3]);
          var i2 = n2 - e4, o3 = "translate(" + St(wt(e4, i2) + "%", "0") + ")", a2 = "scale(" + St(i2 / 100, "1") + ")";
          S2[t3].style[r2.transformRule] = o3 + " " + a2;
        }
      }
      function Ot(t3, e4) {
        return t3 === null || t3 === false || t3 === void 0 ? V2[e4] : (typeof t3 == "number" && (t3 = String(t3)), (t3 = r2.format.from(t3)) !== false && (t3 = O2.toStepping(t3)), t3 === false || isNaN(t3) ? V2[e4] : t3);
      }
      function kt(t3, e4, n2) {
        var i2 = f2(t3), o3 = V2[0] === void 0;
        e4 = e4 === void 0 || e4, r2.animate && !o3 && c2(C2, r2.cssClasses.tap, r2.animationDuration), A2.forEach(function(t4) {
          Nt(t4, Ot(i2[t4], t4), true, false, n2);
        });
        var a2 = A2.length === 1 ? 0 : 1;
        if (o3 && O2.hasNoSize() && (n2 = true, V2[0] = 0, A2.length > 1)) {
          var s4 = 100 / (A2.length - 1);
          A2.forEach(function(t4) {
            V2[t4] = t4 * s4;
          });
        }
        for (; a2 < A2.length; ++a2)
          A2.forEach(function(t4) {
            Nt(t4, V2[t4], true, true, n2);
          });
        Et(), A2.forEach(function(t4) {
          bt("update", t4), i2[t4] !== null && e4 && bt("set", t4);
        });
      }
      function Vt(t3) {
        kt(r2.start, t3);
      }
      function At(t3, e4, r3, n2) {
        if (!((t3 = Number(t3)) >= 0 && t3 < A2.length))
          throw new Error("noUiSlider: invalid handle number, got: " + t3);
        Nt(t3, Ot(e4, t3), true, true, n2), bt("update", t3), r3 && bt("set", t3);
      }
      function jt(t3) {
        if (t3 === void 0 && (t3 = false), t3)
          return k2.length === 1 ? k2[0] : k2.slice(0);
        var e4 = k2.map(r2.format.to);
        return e4.length === 1 ? e4[0] : e4;
      }
      function Mt() {
        for (gt(L.aria), gt(L.tooltips), Object.keys(r2.cssClasses).forEach(function(t3) {
          m2(C2, r2.cssClasses[t3]);
        }); C2.firstChild; )
          C2.removeChild(C2.firstChild);
        delete C2.noUiSlider;
      }
      function Ut(t3) {
        var e4 = V2[t3], n2 = O2.getNearbySteps(e4), i2 = k2[t3], o3 = n2.thisStep.step, a2 = null;
        if (r2.snap)
          return [i2 - n2.stepBefore.startValue || null, n2.stepAfter.startValue - i2 || null];
        o3 !== false && i2 + o3 > n2.stepAfter.startValue && (o3 = n2.stepAfter.startValue - i2), a2 = i2 > n2.thisStep.startValue ? n2.thisStep.step : n2.stepBefore.step !== false && i2 - n2.stepBefore.highestStep, e4 === 100 ? o3 = null : e4 === 0 && (a2 = null);
        var s4 = O2.countStepDecimals();
        return o3 !== null && o3 !== false && (o3 = Number(o3.toFixed(s4))), a2 !== null && a2 !== false && (a2 = Number(a2.toFixed(s4))), [a2, o3];
      }
      function Dt() {
        return A2.map(Ut);
      }
      function Lt(t3, e4) {
        var n2 = jt(), o3 = ["margin", "limit", "padding", "range", "animate", "snap", "step", "format", "pips", "tooltips"];
        o3.forEach(function(e5) {
          t3[e5] !== void 0 && (s3[e5] = t3[e5]);
        });
        var a2 = at(s3);
        o3.forEach(function(e5) {
          t3[e5] !== void 0 && (r2[e5] = a2[e5]);
        }), O2 = a2.spectrum, r2.margin = a2.margin, r2.limit = a2.limit, r2.padding = a2.padding, r2.pips ? tt2(r2.pips) : Z2(), r2.tooltips ? $2() : I2(), V2 = [], kt(i(t3.start) ? t3.start : n2, e4);
      }
      function Tt() {
        u3 = B2(C2), R2(r2.connect, u3), ht(r2.events), kt(r2.start), r2.pips && tt2(r2.pips), r2.tooltips && $2(), W2();
      }
      Tt();
      var zt = { destroy: Mt, steps: Dt, on: mt, off: gt, get: jt, set: kt, setHandle: At, reset: Vt, __moveHandles: function(t3, e4, r3) {
        xt(t3, e4, V2, r3);
      }, options: s3, updateOptions: Lt, target: C2, removePips: Z2, removeTooltips: I2, getPositions: function() {
        return V2.slice();
      }, getTooltips: function() {
        return P3;
      }, getOrigins: function() {
        return d3;
      }, pips: tt2 };
      return zt;
    }
    function lt(t3, e3) {
      if (!t3 || !t3.nodeName)
        throw new Error("noUiSlider: create requires a single element, got: " + t3);
      if (t3.noUiSlider)
        throw new Error("noUiSlider: Slider was already initialized.");
      var r2 = st(t3, at(e3), e3);
      return t3.noUiSlider = r2, r2;
    }
    var ut = { __spectrum: M, cssClasses: D, create: lt };
    t2.create = lt, t2.cssClasses = D, t2.default = ut, Object.defineProperty(t2, "__esModule", { value: true });
  }(e);
}));
function w(t, e) {
  if (!Array.isArray(t) || !Array.isArray(e))
    return false;
  var r = e.slice().sort();
  return t.length === e.length && t.slice().sort().every(function(t2, e2) {
    return t2 === r[e2];
  });
}
function P(t) {
  return P = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t2) {
    return typeof t2;
  } : function(t2) {
    return t2 && typeof Symbol == "function" && t2.constructor === Symbol && t2 !== Symbol.prototype ? "symbol" : typeof t2;
  }, P(t);
}
var E = { name: "Slider", emits: ["input", "update:modelValue", "update", "change"], props: __spreadProps(__spreadValues({}, { value: { validator: function(t) {
  return (t2) => typeof t2 == "number" || t2 instanceof Array || t2 == null || t2 === false;
}, required: false }, modelValue: { validator: function(t) {
  return (t2) => typeof t2 == "number" || t2 instanceof Array || t2 == null || t2 === false;
}, required: false } }), { id: { type: [String, Number], required: false }, disabled: { type: Boolean, required: false, default: false }, min: { type: Number, required: false, default: 0 }, max: { type: Number, required: false, default: 100 }, step: { type: Number, required: false, default: 1 }, orientation: { type: String, required: false, default: "horizontal" }, direction: { type: String, required: false, default: "ltr" }, tooltips: { type: Boolean, required: false, default: true }, options: { type: Object, required: false, default: () => ({}) }, merge: { type: Number, required: false, default: -1 }, format: { type: [Object, Function, Boolean], required: false, default: null }, classes: { type: Object, required: false, default: () => ({}) }, showTooltip: { type: String, required: false, default: "always" }, tooltipPosition: { type: String, required: false, default: null }, lazy: { type: Boolean, required: false, default: true } }), setup(a, s2) {
  const l = function(r, n, i) {
    var o2 = toRefs(r), a2 = o2.value, s3 = o2.modelValue, l2 = n.expose !== void 0 ? s3 : a2, c3 = ref(l2.value);
    if (u(l2.value))
      throw new Error("Slider v-model must be a Number or Array");
    if (Array.isArray(l2.value) && l2.value.length == 0)
      throw new Error("Slider v-model must not be an empty array");
    return { value: l2, initialValue: c3 };
  }(a, s2), c2 = function(e, n, i) {
    var o2 = toRefs(e), a2 = o2.classes, s3 = o2.showTooltip, l2 = o2.tooltipPosition, u2 = o2.orientation, c3 = computed(function() {
      return p({ target: "slider-target", focused: "slider-focused", tooltipFocus: "slider-tooltip-focus", tooltipDrag: "slider-tooltip-drag", ltr: "slider-ltr", rtl: "slider-rtl", horizontal: "slider-horizontal", vertical: "slider-vertical", textDirectionRtl: "slider-txt-dir-rtl", textDirectionLtr: "slider-txt-dir-ltr", base: "slider-base", connects: "slider-connects", connect: "slider-connect", origin: "slider-origin", handle: "slider-handle", handleLower: "slider-handle-lower", handleUpper: "slider-handle-upper", touchArea: "slider-touch-area", tooltip: "slider-tooltip", tooltipTop: "slider-tooltip-top", tooltipBottom: "slider-tooltip-bottom", tooltipLeft: "slider-tooltip-left", tooltipRight: "slider-tooltip-right", tooltipHidden: "slider-tooltip-hidden", active: "slider-active", draggable: "slider-draggable", tap: "slider-state-tap", drag: "slider-state-drag", pips: "slider-pips", pipsHorizontal: "slider-pips-horizontal", pipsVertical: "slider-pips-vertical", marker: "slider-marker", markerHorizontal: "slider-marker-horizontal", markerVertical: "slider-marker-vertical", markerNormal: "slider-marker-normal", markerLarge: "slider-marker-large", markerSub: "slider-marker-sub", value: "slider-value", valueHorizontal: "slider-value-horizontal", valueVertical: "slider-value-vertical", valueNormal: "slider-value-normal", valueLarge: "slider-value-large", valueSub: "slider-value-sub" }, a2.value);
    });
    return { classList: computed(function() {
      var t = p({}, c3.value);
      return Object.keys(t).forEach(function(e2) {
        t[e2] = Array.isArray(t[e2]) ? t[e2].filter(function(t2) {
          return t2 !== null;
        }).join(" ") : t[e2];
      }), s3.value !== "always" && (t.target += " ".concat(s3.value === "drag" ? t.tooltipDrag : t.tooltipFocus)), u2.value === "horizontal" && (t.tooltip += l2.value === "bottom" ? " ".concat(t.tooltipBottom) : " ".concat(t.tooltipTop)), u2.value === "vertical" && (t.tooltip += l2.value === "right" ? " ".concat(t.tooltipRight) : " ".concat(t.tooltipLeft)), t;
    }) };
  }(a), f2 = y(a, 0, { value: l.value, classList: c2.classList }), d2 = function(a2, s3, l2) {
    var c3 = toRefs(a2), p2 = c3.orientation, f3 = c3.direction, d3 = c3.tooltips, h2 = c3.step, m2 = c3.min, v2 = c3.max, g2 = c3.merge, b2 = c3.id, y2 = c3.disabled, S2 = c3.options, E2 = c3.classes, N = c3.format, C = c3.lazy, O = l2.value, k = l2.initialValue, V = l2.tooltipsFormat, A = l2.tooltipsMerge, j = l2.classList, M = ref(null), U = ref(null), D = ref(false), L = computed(function() {
      var t = { cssPrefix: "", cssClasses: j.value, orientation: p2.value, direction: f3.value, tooltips: !!d3.value && V.value, connect: "lower", start: u(O.value) ? m2.value : O.value, range: { min: m2.value, max: v2.value } };
      return h2.value > 0 && (t.step = h2.value), Array.isArray(O.value) && (t.connect = true), t;
    }), T = computed(function() {
      var t = { id: b2 && b2.value ? b2.value : void 0 };
      return y2.value && (t.disabled = true), t;
    }), z = computed(function() {
      return Array.isArray(O.value);
    }), F = function() {
      var t = U.value.get();
      return Array.isArray(t) ? t.map(function(t2) {
        return parseFloat(t2);
      }) : parseFloat(t);
    }, H = function(t) {
      var e = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
      U.value.set(t, e);
    }, q = function(t) {
      s3.emit("input", t), s3.emit("update:modelValue", t), s3.emit("update", t);
    }, R = function() {
      U.value = x.create(M.value, Object.assign({}, L.value, S2.value)), d3.value && z.value && g2.value >= 0 && A(M.value, g2.value, " - "), U.value.on("set", function(t) {
        var e = F();
        s3.emit("change", e), C.value && q(e);
      }), U.value.on("update", function(t) {
        if (D.value) {
          var e = F();
          z.value && w(O.value, e) || !z.value && O.value == e ? s3.emit("update", e) : C.value || q(e);
        }
      }), M.value.querySelectorAll("[data-handle]").forEach(function(t) {
        t.onblur = function() {
          j.value.focused.split(" ").forEach(function(t2) {
            M.value.classList.remove(t2);
          });
        }, t.onfocus = function() {
          j.value.focused.split(" ").forEach(function(t2) {
            M.value.classList.add(t2);
          });
        };
      }), D.value = true;
    }, B = function() {
      U.value.off(), U.value.destroy(), U.value = null;
    }, _ = function(t, e) {
      D.value = false, B(), R();
    };
    return onMounted(R), onUnmounted(B), watch(O, function(t, e) {
      e && (P(e) === "object" && P(t) === "object" && t && Object.keys(e) > Object.keys(t) || P(e) === "object" && P(t) !== "object" || !t) && _();
    }, { immediate: false }), watch(z, _, { immediate: false }), watch(m2, _, { immediate: false }), watch(v2, _, { immediate: false }), watch(h2, _, { immediate: false }), watch(p2, _, { immediate: false }), watch(f3, _, { immediate: false }), watch(d3, _, { immediate: false }), watch(g2, _, { immediate: false }), watch(N, _, { immediate: false, deep: true }), watch(S2, _, { immediate: false, deep: true }), watch(E2, _, { immediate: false, deep: true }), watch(O, function(t) {
      if (u(t))
        H(m2.value, false);
      else {
        var e = F();
        z.value && !Array.isArray(e) && (e = [e]), (z.value && !w(t, e) || !z.value && t != e) && H(t, false);
      }
    }, { deep: true }), { slider: M, slider$: U, isRange: z, sliderProps: T, init: R, destroy: B, refresh: _, update: H, reset: function() {
      q(k.value);
    } };
  }(a, s2, { value: l.value, initialValue: l.initialValue, tooltipsFormat: f2.tooltipsFormat, tooltipsMerge: f2.tooltipsMerge, classList: c2.classList });
  return __spreadValues(__spreadValues(__spreadValues({}, c2), f2), d2);
} };
E.render = function(t, e, r, n, i, o2) {
  return openBlock(), createElementBlock("div", mergeProps(t.sliderProps, { ref: "slider" }), null, 16);
}, E.__file = "src/Slider.vue";
function o(e, l) {
  var a = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    l && (n = n.filter(function(l2) {
      return Object.getOwnPropertyDescriptor(e, l2).enumerable;
    })), a.push.apply(a, n);
  }
  return a;
}
function f(e, l, a) {
  return l in e ? Object.defineProperty(e, l, { value: a, enumerable: true, configurable: true, writable: true }) : e[l] = a, e;
}
function s(a, n, t) {
  var u2 = toRefs(a), r = u2.disabled, d2 = t.checked, i = computed(function() {
    return function(e) {
      for (var l = 1; l < arguments.length; l++) {
        var a2 = arguments[l] != null ? arguments[l] : {};
        l % 2 ? o(Object(a2), true).forEach(function(l2) {
          f(e, l2, a2[l2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(a2)) : o(Object(a2)).forEach(function(l2) {
          Object.defineProperty(e, l2, Object.getOwnPropertyDescriptor(a2, l2));
        });
      }
      return e;
    }({ container: "toggle-container", toggle: "toggle", toggleOn: "toggle-on", toggleOff: "toggle-off", toggleOnDisabled: "toggle-on-disabled", toggleOffDisabled: "toggle-off-disabled", handle: "toggle-handle", handleOn: "toggle-handle-on", handleOff: "toggle-handle-off", handleOnDisabled: "toggle-handle-on-disabled", handleOffDisabled: "toggle-handle-off-disabled", label: "toggle-label" }, u2.classes.value);
  });
  return { classList: computed(function() {
    return { container: i.value.container, toggle: [i.value.toggle, r.value ? d2.value ? i.value.toggleOnDisabled : i.value.toggleOffDisabled : d2.value ? i.value.toggleOn : i.value.toggleOff], handle: [i.value.handle, r.value ? d2.value ? i.value.handleOnDisabled : i.value.handleOffDisabled : d2.value ? i.value.handleOn : i.value.handleOff], label: i.value.label };
  }) };
}
var b = { name: "Toggle", emits: ["input", "update:modelValue", "change"], props: __spreadProps(__spreadValues({}, { value: { validator: function(e) {
  return (e2) => ["number", "string", "boolean"].indexOf(typeof e2) !== -1 || e2 == null;
}, required: false }, modelValue: { validator: function(e) {
  return (e2) => ["number", "string", "boolean"].indexOf(typeof e2) !== -1 || e2 == null;
}, required: false } }), { id: { type: [String, Number], required: false, default: "toggle" }, name: { type: [String, Number], required: false, default: "toggle" }, disabled: { type: Boolean, required: false, default: false }, required: { type: Boolean, required: false, default: false }, falseValue: { type: [String, Number, Boolean], required: false, default: false }, trueValue: { type: [String, Number, Boolean], required: false, default: true }, onLabel: { type: [String, Object], required: false, default: "" }, offLabel: { type: [String, Object], required: false, default: "" }, classes: { type: Object, required: false, default: () => ({}) }, labelledby: { type: String, required: false }, describedby: { type: String, required: false } }), setup(a, n) {
  const t = function(a2, n2, t2) {
    var u3 = toRefs(a2), r2 = u3.value, d3 = u3.modelValue, i = u3.falseValue, c2 = u3.trueValue, o2 = u3.disabled, f2 = n2.expose !== void 0 ? d3 : r2, s2 = computed(function() {
      return f2.value === c2.value;
    }), b2 = function(e) {
      n2.emit("input", e), n2.emit("update:modelValue", e), n2.emit("change", e);
    }, g2 = function() {
      b2(c2.value);
    }, v2 = function() {
      b2(i.value);
    };
    return [null, void 0, false, 0, "0", "off"].indexOf(f2.value) !== -1 && [i.value, c2.value].indexOf(f2.value) === -1 && v2(), [true, 1, "1", "on"].indexOf(f2.value) !== -1 && [i.value, c2.value].indexOf(f2.value) === -1 && g2(), { externalValue: f2, checked: s2, update: b2, check: g2, uncheck: v2, handleInput: function(e) {
      b2(e.target.checked ? c2.value : i.value);
    }, handleClick: function() {
      o2.value || (s2.value ? v2() : g2());
    } };
  }(a, n), u2 = function(a2, n2, t2) {
    var u3 = toRefs(a2), r2 = u3.trueValue, d3 = u3.falseValue, i = u3.onLabel, c2 = u3.offLabel, o2 = t2.checked, f2 = t2.update;
    return { label: computed(function() {
      var e = o2.value ? i.value : c2.value;
      return e || (e = "&nbsp;"), e;
    }), toggle: function() {
      f2(o2.value ? d3.value : r2.value);
    }, on: function() {
      f2(r2.value);
    }, off: function() {
      f2(d3.value);
    } };
  }(a, 0, { checked: t.checked, update: t.update }), r = s(a, 0, { checked: t.checked }), d2 = function(l, a2, n2) {
    var t2 = toRefs(l).disabled, u3 = n2.check, r2 = n2.uncheck, d3 = n2.checked;
    return { handleSpace: function() {
      t2.value || (d3.value ? r2() : u3());
    } };
  }(a, 0, { check: t.check, uncheck: t.uncheck, checked: t.checked });
  return __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, t), r), u2), d2);
} };
b.render = function(e, l, o2, f2, s2, b2) {
  return openBlock(), createBlock("div", { class: e.classList.container, tabindex: o2.disabled ? void 0 : 0, "aria-checked": e.checked, "aria-describedby": o2.describedby, "aria-labelledby": o2.labelledby, role: "switch", onKeyup: l[2] || (l[2] = withKeys((...l2) => e.handleSpace && e.handleSpace(...l2), ["space"])) }, [withDirectives(createVNode("input", { type: "checkbox", id: o2.id, name: o2.name, value: o2.trueValue, checked: e.checked, disabled: o2.disabled }, null, 8, ["id", "name", "value", "checked", "disabled"]), [[vShow, false]]), createVNode("div", { class: e.classList.toggle, onClick: l[1] || (l[1] = (...l2) => e.handleClick && e.handleClick(...l2)) }, [createVNode("span", { class: e.classList.handle }, null, 2), renderSlot(e.$slots, "label", { checked: e.checked, classList: e.classList }, () => [createVNode("span", { class: e.classList.label, innerHTML: e.label }, null, 10, ["innerHTML"])]), o2.required ? (openBlock(), createBlock("input", { key: 0, type: "checkbox", style: { appearance: "none", height: "1px", margin: "0", padding: "0", fontSize: "0", background: "transparent", position: "absolute", width: "100%", bottom: "0", outline: "none" }, checked: e.checked, "aria-hidden": "true", tabindex: "-1", required: "" }, null, 8, ["checked"])) : createCommentVNode("v-if", true)], 2)], 42, ["tabindex", "aria-checked", "aria-describedby", "aria-labelledby"]);
}, b.__file = "src/Toggle.vue";
var _sfc_main = {
  components: {
    Slider: E,
    Toggle: b
  },
  inject: ["root"],
  data() {
    return {
      xScaleValue: this.root.state.options.times.timeZoom,
      yScaleValue: this.root.state.options.row.height,
      before: this.root.state.options.scope.before,
      divider: this.root.state.options.taskList.percent
    };
  },
  methods: {
    onXScaleChange(value) {
      this.$root.emitter.emit("times-timeZoom-change", value);
    },
    onYScaleChange(value) {
      this.$root.emitter.emit("row-height-change", value);
    },
    recenterPosition() {
      this.$root.emitter.emit("recenterPosition");
    },
    onBeforeChange(value) {
      this.$root.emitter.emit("scope-change", value);
    },
    onDividerChange(value) {
      this.$root.emitter.emit("taskList-width-change", value);
    }
  }
};
var _hoisted_1 = { style: { "margin": "16px 0px" } };
var _hoisted_2 = { style: { "display": "flex", "align-items": "center", "justify-content": "end" } };
var _hoisted_3 = { style: { "display": "flex", "align-items": "center" } };
var _hoisted_4 = createBaseVNode("div", { style: { "margin": "0px 16px" } }, " X-Scale ", -1);
var _hoisted_5 = { style: { "display": "flex", "align-items": "center" } };
var _hoisted_6 = createBaseVNode("div", { style: { "margin": "0px 16px" } }, " Y-Scale ", -1);
var _hoisted_7 = { style: { "display": "flex", "align-items": "center" } };
var _hoisted_8 = createBaseVNode("div", { style: { "margin": "0px 16px" } }, " Task list ", -1);
var _hoisted_9 = { style: { "margin-left": "16px" } };
var _hoisted_10 = createTextVNode(" showTaskList ");
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Slider = resolveComponent("Slider");
  const _component_Toggle = resolveComponent("Toggle");
  return openBlock(), createElementBlock("div", _hoisted_1, [
    createBaseVNode("div", _hoisted_2, [
      createBaseVNode("button", {
        onClick: _cache[0] || (_cache[0] = withModifiers((...args) => $options.recenterPosition && $options.recenterPosition(...args), ["prevent"])),
        class: "header-btn-recenter"
      }, " Now "),
      createBaseVNode("div", _hoisted_3, [
        _hoisted_4,
        createVNode(_component_Slider, {
          modelValue: $data.xScaleValue,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.xScaleValue = $event),
          min: 2,
          max: 24,
          tooltips: false,
          style: { "min-width": "100px" },
          onChange: $options.onXScaleChange
        }, null, 8, ["modelValue", "onChange"])
      ]),
      createBaseVNode("div", _hoisted_5, [
        _hoisted_6,
        createVNode(_component_Slider, {
          modelValue: $data.yScaleValue,
          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.yScaleValue = $event),
          min: 7,
          max: 100,
          tooltips: false,
          style: { "min-width": "100px" },
          onChange: $options.onYScaleChange
        }, null, 8, ["modelValue", "onChange"])
      ]),
      createBaseVNode("div", _hoisted_7, [
        _hoisted_8,
        createVNode(_component_Slider, {
          modelValue: $data.divider,
          "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $data.divider = $event),
          min: 0,
          max: 100,
          tooltips: false,
          style: { "min-width": "100px" },
          onChange: $options.onDividerChange
        }, null, 8, ["modelValue", "onChange"])
      ]),
      createBaseVNode("div", _hoisted_9, [
        createVNode(_component_Toggle, {
          modelValue: $options.root.state.options.taskList.display,
          "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => $options.root.state.options.taskList.display = $event)
        }, null, 8, ["modelValue"]),
        _hoisted_10
      ])
    ])
  ]);
}
var GanttElasticHeader2 = _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  GanttElastic$1 as GanttElastic,
  GanttElasticHeader2
};
/*! Bundled license information:

gantt-elastic-wrapvue3/dist/GanttElastic.es.js:
  (**
   * @fileoverview Task mixin
   * @license MIT
   * @author Rafal Pospiech <neuronet.io@gmail.com>
   * @package GanttElastic
   *)
  (**
   * @fileoverview Styles for gantt-elastic
   * @license MIT
   * @author Rafal Pospiech <neuronet.io@gmail.com>
   * @package GanttElastic
   *)
*/
//# sourceMappingURL=gantt-elastic-wrapvue3.js.map
